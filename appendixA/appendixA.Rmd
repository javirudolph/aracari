---
title: "Appendix A"
subtitle: "Model fitting and selection for tracking data"
output:
  html_document:
      toc: true
bibliography: "../paper/mybibfile.bib"
---

# Overall description 

We have used the data collected by Kimberly Holbrook for her studies on toucan home ranges and movement patterns [@holbrook_home_2011]. We cleaned original data similarly, as is shown in the `raw-data/newpointlocs.R` file of this directory, by restricting the individuals to those with a minimum of 40 observations and locations collected in intervals from 15 to 90 minutes in multiples of 15 minutes. As shown in previous studies [@holbrook_using_2007], the distances traveled by toucans in 15-30 minutes represent the most probable distances for seed dispersal. Due to data collection constraints, locations could not be obtained every 15 minutes, and birds were sometimes located at greater time intervals. Our goal in this section is to use a probabilistic approach that will characterize the pattern of distances moved, and use these probability distributions to later randomly sample distances from. In order to do this, we scaled the original data in distances moved per time interval, to distances moved per minute. 

Our approach involves fitting these probability distributions at three different levels: population, individual, and family. In the case of population level fittings, a probability distribution is used to fit all the data available, and a single distribution is used to describe the population's distanced moved. At the individual level, each bird is analyzed separately and a single distribution is assigned to the data of each individual bird to characterize it's distances moved. The family level analysis is restricted to the data points for which we have available information on family group. In this case, a single probability distribution is used for each individual family group to describe the distances moved. 

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE, results = 'hide')
```

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(purrr)
library(fitdistrplus)
library(ggpubr)

theme_set(theme_bw())
```

```{r functions}


# Extract parameters from fitted distributions to the data
build.fits.df <- function(x){
  
  nm <- deparse(substitute(x))
  
  x %>% 
  map(., `[`, c("estimate", "sd", "loglik", "n")) %>% 
  map(as_tibble) %>% 
  bind_rows()
}


```

The way we are fitting the data can be visualized as follows, where each curve represents the population, an individual, or a family group: 

```{r data}
# Get the data loaded. We are removing the one value with zero since it won't allow fitting.

load("data/newpointlocs.rda")

df <- newpointlocs %>%
  dplyr::filter(mpm != 0) %>%
  ungroup() %>%
  mutate(Bird_ID = paste0("B", Bird_ID),
         sqR2n = sqrt(R2n)) %>% 
  group_by_("id", "burst") %>% 
  mutate(cumdt = cumsum(dt)/60) %>% 
  ungroup()


dist.used <- c( "exp", "gamma", "weibull", "lnorm")


param <- c("rate", "shape", "rate", "shape", "scale", "meanlog", "sdlog")
dist <- c("exp", "gamma", "gamma", "weibull", "weibull", "lnorm", "lnorm")

```


```{r fig.width=10}
pop_dens_plot <- df %>%
  ggplot(., aes(x = mpm)) +
  geom_line(stat = "density", color = "grey", lwd = 1) +
  #geom_line(aes(x = dist, group = id), stat = "density", alpha = 0.4) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  ylim(0, 0.05) +
  labs(title = "Population") +
  theme_classic()

ind_dens_plot <- df %>%
  ggplot(., aes(x = mpm)) +
  #geom_line(stat = "density", color = "red", lwd = 1) +
  geom_line(aes(x = mpm, group = id), stat = "density", alpha = 0.4) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  ylim(0, 0.05) +
  labs(title = "Individual") +
  theme_classic()

fam_dens_plot <- df %>%
  filter(., fam_g != "unknown") %>% 
  ggplot(., aes(x = mpm)) +
  #geom_line(stat = "density", color = "red", lwd = 1) +
  geom_line(aes(x = mpm, group = fam_g), stat = "density", alpha = 0.4) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  ylim(0, 0.05) +
  labs(title = "Family") +
  theme_classic()

ggarrange(pop_dens_plot, ind_dens_plot, fam_dens_plot, ncol = 3)

```
We have chosen five common probability distributions, which are readily used in animal-mediated seed dispersal simulations. These are an exponential distribution [@jones_closing_2017], a gamma distribution, Weibull distribution [@morales_effects_2006], and lognormal distribution [@levey_effects_2005]. The goal of this project is to evaluate variation in movement and how that translates to differences in seed dispersal estimates. Our first comparisson is made between population level and individual level estimates. Not all individual birds had information on family group, therefore, for our second comparisson between population level and family level fits, we used a reduced dataset with only data from individual for which we had family group information. We assessed fits visually through QQ plots.

# Population and Individual level comparissons 

At the population level analysis, we observe that the lognormal distribution has considerable overestimation of distances towards the tail. Although this is also worth noting in the QQ plots for individuals, not all of the individual have an overestimation, and for some other distributions seem to do a better job at characterizing the pattern. 

```{r poplevel, fig.height = 3}

pop <- lapply(dist.used, function(x){fitdist(df$mpm, distr = x)})

qqpop <- qqcomp(pop, plotstyle = "ggplot")
  
qqpop +
  coord_equal() +
  geom_point(shape = 16, alpha = 0.5) +
  labs(title = "Population level QQ plot")
  scale_color_viridis_d()

prms.df <- build.fits.df(pop) %>% 
  mutate(param = param,
         dist = dist,
         data = "pop")

```


```{r}
inds <- unique(as.character(df$Bird_ID))
#inds

for(i in 1:length(inds)){
  fit.df <- df %>% 
    dplyr::filter(., Bird_ID == inds[i])
  
  fit <- lapply(dist.used, function(x){fitdist(fit.df$mpm, distr = x)})
  
  assign(paste(inds[i]), fit)
  
  fit.prms <- build.fits.df(fit) %>% 
  mutate(param = param,
         dist = dist,
         data = inds[i])
  
  prms.df <- bind_rows(prms.df, fit.prms)
}
```

```{r fig.height=5}

inds.models.data <- NULL
ind.models <- list(B1, B13, B19, B22, B28, B29, B3, B30, B49, B5, B7, B84)
chr.models <- c("B1", "B13", "B19", "B22", "B28", "B29", "B3", "B30", "B49", "B5", "B7", "B84")
for(i in 1:12){
  x <- ind.models[[i]]
  
  qqdata <- qqcomp(x, plotstyle = "ggplot")$data %>% 
    mutate(data = chr.models[i])
  names(qqdata) <- c("theoretical", "fdist", "empirical", "individual")
  inds.models.data <- bind_rows(inds.models.data, qqdata)
}

inds.models.data%>% 
  ggplot(., aes(x = theoretical, y = empirical, color = fdist)) +
  facet_wrap(~individual)+
    geom_point(cex = 2, alpha = 0.6) +
    geom_abline(intercept = 0, slope = 1) +
    labs(x = "Model Quantiles",
         y = "Empirical Quantiles") +
  scale_color_viridis_d() + 
  theme(legend.position = "top") +
  guides(color = guide_legend(title = "Distribution")) +
  coord_equal()
  

```


## Information criteria assessment of individual level distribution fits
Need to add the description here of how we calculated these information criteria and the reasoning as to why we decided to go with just the BIC, because of Jose's paper. Explain here what the mixed distribution model means, vs the others that use one distribution but allow variation in the parameters. 

```{r}
all_indiv_prms <- prms.df %>% 
  mutate(kpars = ifelse(dist == "exp", 1, 2),
         BIC = log(n)*kpars - 2*loglik,
         AIC = 2*kpars - 2*loglik,
         AICc = AIC + (2* kpars * (kpars+1)/(n-kpars-1))) %>% 
  group_by(data) %>% 
  mutate(deltaBIC = signif(BIC - min(BIC), 3),
         deltaAIC = signif(AIC - min(AIC), 3),
         deltaAICc = signif(AICc - min(AICc), 3))
#saveRDS(all_indiv_prms, file = "outputs/prms_indiv.RDS")

prms.df %>% 
  dplyr::select(., loglik, n, dist, data) %>% 
  distinct() %>% 
  mutate(kpars = ifelse(dist == "exp", 1, 2),
         BIC = log(n)*kpars - 2*loglik,
         AIC = 2*kpars - 2*loglik,
         AICc = AIC + (2* kpars * (kpars+1)/(n-kpars-1))) %>% 
  group_by(data) %>% 
  mutate(deltaBIC = signif(BIC - min(BIC), 3),
         deltaAIC = signif(AIC - min(AIC), 3),
         deltaAICc = signif(AICc - min(AICc), 3)) -> popind.IC

```

```{r}
popind.IC %>% 
  pivot_longer(., cols = starts_with("delta"), names_to = "ic", values_to = "value") %>% 
  ggplot(., aes(x = ic, y = value, color = dist)) +
  geom_point() +
  facet_wrap(~data, scales = "free")
```


```{r}
prms.df %>% 
  filter(., data != "pop") %>%
  dplyr::select(., loglik, n, dist) %>% 
  distinct() %>%
  mutate(kpars = ifelse(dist == "exp", 1, 2)) %>% 
  group_by(dist) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik), 
            AIC = 2*(sum(kpars)) - 2*(sum(loglik)),
            AICc = 2*(sum(kpars)) - 2*(sum(loglik)) + (2* sum(kpars) * (sum(kpars)+1)/(sum(n)-sum(kpars)-1))) %>%
    mutate(deltaAIC = signif(AIC - min(AIC), 3),
         deltaAICc = signif(AICc - min(AICc), 3),
         deltaBIC = signif(BIC - min(BIC), 3),
         data = "ind") %>% 
  full_join(., popind.IC %>% 
  filter(., data == "pop")) -> popind.IC.comp

```


```{r}
prms.df %>% 
  mutate(fit.param = paste(dist, param)) %>% 
  ggplot(., aes(x = data, y = estimate, color = dist)) +
  facet_wrap(~fit.param, scales = "free") +
  geom_point() +
  geom_errorbar(aes(ymin = estimate - sd, ymax = estimate + sd)) +
  theme(legend.position = "none")
```


```{r}
popind.IC.comp %>% 
  pivot_longer(., cols = starts_with("delta"), names_to = "ic", values_to = "value") %>% 
  ggplot(., aes(x = ic, y = value, color = dist)) +
  geom_point() +
  facet_wrap(~data, scales = "free")
```

```{r}

# Get the multi-distribution model fit
popind.IC %>% 
  dplyr::filter(., data != "pop" & deltaBIC == 0) %>% 
  ungroup() %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) %>% 
  as.numeric() -> multi.BIC

popind.IC %>% 
  dplyr::filter(., data != "pop" & deltaAIC == 0) %>% 
  ungroup() %>% 
  summarise(AIC = 2*(sum(kpars)) - 2*(sum(loglik))) %>% 
  as.numeric() -> multi.AIC

popind.IC %>% 
  dplyr::filter(., data != "pop" & deltaAICc == 0) %>% 
  ungroup() %>% 
  summarise(AICc = 2*(sum(kpars)) - 2*(sum(loglik)) + (2* sum(kpars) * (sum(kpars)+1)/(sum(n)-sum(kpars)-1))) %>% 
  as.numeric()-> multi.AICc

popind.IC.comp %>% 
  dplyr::select(., dist, BIC, AIC, AICc, data) %>% 
  bind_rows(., data.frame(dist = "multi", BIC = multi.BIC, AIC = multi.AIC, AICc = multi.AICc, data = "multi")) %>%
  pivot_longer(., cols = starts_with(c("BIC", "AIC")), names_to = "ic", values_to = "value") %>% 
  ggplot(., aes(x = dist, y = value, color = data)) +
  geom_point() +
  facet_wrap(~ic, scales = "free") +
  theme(axis.text.x = element_text(angle = 90))

```

Summary: When comparing population vs individual level fits, at the population level, the lognormal distribution fits the data better, and at the individual level it is the exponential distribution. When we focus only on the individual level fits, which distribution fits best depends on the information criteria considered, although most of the individuals are properly characterized by an exponential or lognormal distribution. What we consider as the multi distribution, it is a multi-distribution probability fit to the data in which we have allowed not only the parameters but also the shape of the distribution to vary between individuals. This means that each individual can be characterized by a different distribution and different parameters. In the case of AIC and AICc, this probability approach works best for the data, however when considering BIC, the lognormal fit is best, and the mixed distribution approach ties with a weibull distribution at population level. Using BIC, a population level modeling approach is the best.

# Population vs Family

## Population level - restricted
Keep in mind that the family level data is reduced because some individuals had unknown family groups and therefore are not included in this analysis.This means that we cannot directly compare distribution fits from family level aggregation with that of individuals. To make a comparisson with the population, we need to keep only data points for which we have family information

```{r}
fams.df <- df %>% 
  dplyr::filter(., fam_g != "unknown")

fams <- paste0("f", 1:6)

pop.fams <- lapply(dist.used, function(x){fitdist(fams.df$mpm, distr = x)})
qqcomp(pop.fams, plotstyle = "ggplot") +
  coord_equal() +
  geom_point(shape = 16, alpha = 0.5)

prms.fams.df <- build.fits.df(pop.fams) %>% 
  mutate(param = param,
         dist = dist,
         data = "pop")

```
## Family level

 

```{r}

for(i in 1:length(fams)){
  fit.df <- fams.df %>% 
    dplyr::filter(., fam_g == fams[i])
  
  fit <- lapply(dist.used, function(x){fitdist(fit.df$mpm, distr = x)})
  
  assign(paste(fams[i]), fit)
  
  fit.prms <- build.fits.df(fit) %>% 
  mutate(param = param,
         dist = dist,
         data = fams[i])
  
  prms.fams.df <- bind_rows(prms.fams.df, fit.prms)
  
}

```


Evaluate via qqplots
```{r}

fams.models.data <- NULL
fams.models <- list(f1, f2, f3, f4, f5, f6)

for(i in 1:6){
  x <- fams.models[[i]]
  
  qqdata <- qqcomp(x, plotstyle = "ggplot")$data %>% 
    mutate(data = fams[i])
  names(qqdata) <- c("theoretical", "fdist", "empirical", "fam.group")
  fams.models.data <- bind_rows(fams.models.data, qqdata)
}

fams.models.data%>% 
  ggplot(., aes(x = theoretical, y = empirical, color = fdist)) +
  facet_wrap(~fam.group)+
    geom_point(cex = 2, alpha = 0.6) +
    geom_abline(intercept = 0, slope = 1) +
    labs(x = "Model Quantiles",
         y = "Empirical Quantiles") +
  #scale_color_viridis_d() + 
  theme(legend.position = "top") +
  guides(color = guide_legend(title = "Distribution")) +
  coord_equal()

```
```{r}
all_fam_prms <- prms.fams.df %>% 
  mutate(kpars = ifelse(dist == "exp", 1, 2),
         BIC = log(n)*kpars - 2*loglik,
         AIC = 2*kpars - 2*loglik,
         AICc = AIC + (2* kpars * (kpars+1)/(n-kpars-1))) %>% 
  group_by(data) %>% 
  mutate(deltaBIC = signif(BIC - min(BIC), 3),
         deltaAIC = signif(AIC - min(AIC), 3),
         deltaAICc = signif(AICc - min(AICc), 3))
```

```{r}
prms.fams.df %>% 
  mutate(fit.param = paste(dist, param)) %>% 
  ggplot(., aes(x = data, y = estimate, color = dist)) +
  facet_wrap(~fit.param, scales = "free") +
  geom_point() +
  geom_errorbar(aes(ymin = estimate - sd, ymax = estimate + sd)) +
  theme(legend.position = "none")
```


## Calculate BIC for comparisons

```{r fig.height=6}
prms.fams.df %>% 
  dplyr::select(., loglik, n, dist, data) %>% 
  distinct() %>% 
  mutate(kpars = ifelse(dist == "exp", 1, 2),
         BIC = log(n)*kpars - 2*loglik,
         AIC = 2*kpars - 2*loglik,
         AICc = AIC + (2* kpars * (kpars+1)/(n-kpars-1))) %>% 
  group_by(data) %>% 
  mutate(deltaBIC = signif(BIC - min(BIC), 3),
         deltaAIC = signif(AIC - min(AIC), 3),
         deltaAICc = signif(AICc - min(AICc), 3)) -> popfam.BIC

popfam.BIC %>% 
  pivot_longer(., cols = starts_with("delta"), names_to = "ic", values_to = "value") %>% 
  ggplot(., aes(x = ic, y = value, color = dist)) +
  geom_point() +
  facet_wrap(~data, scales = "free")


```

Calculate BIC for the model at the family level
```{r}
prms.fams.df %>% 
  filter(., data != "pop") %>%
  dplyr::select(., loglik, n, dist) %>% 
  distinct() %>%
  mutate(kpars = ifelse(dist == "exp", 1, 2)) %>% 
  group_by(dist) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik), 
            AIC = 2*(sum(kpars)) - 2*(sum(loglik)),
            AICc = 2*(sum(kpars)) - 2*(sum(loglik)) + (2* sum(kpars) * (sum(kpars)+1)/(sum(n)-sum(kpars)-1))) %>%
    mutate(deltaAIC = signif(AIC - min(AIC), 3),
         deltaAICc = signif(AICc - min(AICc), 3),
         deltaBIC = signif(BIC - min(BIC), 3),
         data = "fam") %>% 
  full_join(., popfam.BIC %>% 
  filter(., data == "pop")) -> comp.fams

comp.fams %>% 
  pivot_longer(., cols = starts_with("delta"), names_to = "ic", values_to = "value") %>% 
  ggplot(., aes(x = ic, y = value, color = dist)) +
  geom_point() +
  facet_wrap(~data, scales = "free")

comp.fams %>% 
  pivot_longer(., cols = starts_with(c("BIC", "AIC")), names_to = "ic", values_to = "value") %>% 
  ggplot(., aes(x = dist, y = value, color = data)) +
  geom_point() +
  facet_wrap(~ic, scales = "free")

  
```
```{r}

# Get the multi-distribution model fit
popfam.BIC %>% 
  dplyr::filter(., data != "pop" & deltaBIC == 0) %>% 
  ungroup() %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) %>% 
  as.numeric() -> multi.BIC

popfam.BIC %>% 
  dplyr::filter(., data != "pop" & deltaAIC == 0) %>% 
  ungroup() %>% 
  summarise(AIC = 2*(sum(kpars)) - 2*(sum(loglik))) %>% 
  as.numeric() -> multi.AIC

popfam.BIC %>% 
  dplyr::filter(., data != "pop" & deltaAICc == 0) %>% 
  ungroup() %>% 
  summarise(AICc = 2*(sum(kpars)) - 2*(sum(loglik)) + (2* sum(kpars) * (sum(kpars)+1)/(sum(n)-sum(kpars)-1))) %>% 
  as.numeric()-> multi.AICc

comp.fams %>% 
  dplyr::select(., dist, BIC, AIC, AICc, data) %>% 
  bind_rows(., data.frame(dist = "multi", BIC = multi.BIC, AIC = multi.AIC, AICc = multi.AICc, data = "multi")) %>% 
  pivot_longer(., cols = starts_with(c("BIC", "AIC")), names_to = "ic", values_to = "value") %>% 
  ggplot(., aes(x = dist, y = value, color = data)) +
  geom_point() +
  facet_wrap(~ic, scales = "free") +
  theme(axis.text.x = element_text(angle = 90))

```

Summary. As with individuals, the information criteria actually changes things a lot. With AIC and AICc, family level aggregation is a better descriptor of the data, no matter the distribution used, whereas in BIC it is the opposite and population level data is best for all distributions. However, the multidistribution approach, where each family is characterized by its own independent distribution and parameters, no matter the information criteria, this one comes with the lowest value, making the multidistribution approach the best for characterizing the data. 


# References 
