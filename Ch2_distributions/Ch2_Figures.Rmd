---
title: "Distributions"
author: "Javiera Rudolph"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
# knitr::opts_chunk$set(fig.width=12, fig.height=6)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r message=FALSE, warning=FALSE}
library(aracari)
library(dplyr)
library(tidyr)
library(ggplot2)
library(cowplot)
library(fitdistrplus)
library(stringr)
library(gt)
library(MetBrewer)
library(purrr)

```


```{r include=FALSE}
set.seed(20211207)

# Data ----------------------------------------------------
# The script for this data is in the Orig_data_KH
load("Ch2_distributions/Orig_data_KH/tidy_data.RData")


ptpl %>%
  mutate(T_minutes = dt/60,
         Bird_ID = id,
         mpm = dist/T_minutes,
         R2n = lead(R2n)) %>%
  filter(mpm != 0) %>%
  group_by(Bird_ID) %>%
  add_tally() %>%
  filter(n >= 30) -> ptpl
```

# Figure 1 - Density plots for velocity

```{r include=FALSE}
# Color palette ----------------------------------------
my.cols1 <- c("#23262f","#717492","#b3a82a","#c94f21","#980012",
              "#0d907a","#b9bec3","#31aec5", "#653625", "#2C5C5D",
              "#DEB41E", "#2D3335", "#E2BF80", "#87A986", "#59879A",
              "#9C1D29", "#24716B", "#4a92b0")
scales::show_col(my.cols1)

my.cols2 <- c("#23262f", "#0d907a", "#DEB41E", 
              "#9C1D29", "#c76620", "#4a92b0",
              "#669e46", "grey")
scales::show_col(my.cols2)

```

## F1 - Color 

Color version - each social group has a different color.  

```{r Figure1col, fig.width=12, fig.height=4}

zoom_dims <- c(90, 200, 0, 0.01)
annot_xy <- c(50, 200, 0.025, 0.045)
box_color <- "blue"

ind_dens_plot <- ptpl %>%
  ggplot(., aes((x = mpm))) +
  geom_line(aes(x = mpm, group = id, color = sgroup), stat = "density", alpha = 0.8) +
  #geom_line(aes(x = mpm, group = id), color = "grey", stat = "density", alpha = 0.8) +
  geom_line(stat = "density", color = "black", lwd = 1) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  labs(y = "Density", x = "Velocity in m/min") +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[3]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[4], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[1], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[2], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  theme_classic() +
  scale_color_manual(values = my.cols2) +
  theme(legend.position = "none")

ind_dens_plot +
  coord_cartesian(
    xlim = zoom_dims[1:2],
    ylim = zoom_dims[3:4]) +
  theme(title = element_blank()) -> ind_zoom

ind_dens_plot +
  annotation_custom(grob = ggplotGrob(ind_zoom), xmin = annot_xy[1] , xmax = annot_xy[2] , ymin = annot_xy[3] , ymax = annot_xy[4]) -> a


fam_dens_plot <- ptpl %>%
  drop_na(sgroup) %>% 
  ggplot(., aes((x = mpm))) +
  geom_line(aes(x = mpm, group = sgroup, color = sgroup), stat = "density", alpha = 0.8) +
  #geom_line(aes(x = mpm, group = fam_g), color = "grey",stat = "density", alpha = 0.8) +
  geom_line(stat = "density", color = "black", lwd = 1) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  labs(y = "Density", x = "Velocity in m/min") +
    # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[3]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[4], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[1], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[2], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  theme_classic() +
  scale_color_manual(values = my.cols2) +
  theme(legend.position = "none")

fam_dens_plot +
  coord_cartesian(
    xlim = zoom_dims[1:2],
    ylim = zoom_dims[3:4]) +
  theme(title = element_blank()) -> fam_zoom


fam_dens_plot +
  annotation_custom(grob = ggplotGrob(fam_zoom), xmin = annot_xy[1] , xmax = annot_xy[2] , ymin = annot_xy[3] , ymax = annot_xy[4]) -> b

plot_grid(b,a, labels = c("A)", "B)"))

ggsave2(filename = "Ch2_distributions/Figures/Figure1_color.png")
```  

## F1 - BW 

Black and white version seems more clear to me. Maybe worth including a different in the underlying curves to make sure the point comes across that one is for individuals, and the other for social groups.  


```{r Figure1bw, fig.width=12, fig.height=4}

zoom_dims <- c(90, 200, 0, 0.01)
annot_xy <- c(50, 200, 0.025, 0.045)
box_color <- "blue"

ind_dens_plot <- ptpl %>%
  ggplot(., aes((x = mpm))) +
  #geom_line(aes(x = mpm, group = id, color = fam_g), stat = "density", alpha = 0.8) +
  geom_line(aes(x = mpm, group = id), color = "grey", stat = "density", alpha = 0.8) +
  geom_line(stat = "density", color = "black", lwd = 1) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  labs(y = "Density", x = "Velocity in m/min") +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[3]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[4], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[1], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[2], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  theme_classic() +
  scale_color_manual(values = my.cols2) +
  theme(legend.position = "none")

ind_dens_plot +
  coord_cartesian(
    xlim = zoom_dims[1:2],
    ylim = zoom_dims[3:4]) +
  theme(title = element_blank()) -> ind_zoom

ind_dens_plot +
  annotation_custom(grob = ggplotGrob(ind_zoom), xmin = annot_xy[1] , xmax = annot_xy[2] , ymin = annot_xy[3] , ymax = annot_xy[4]) -> a


fam_dens_plot <- ptpl %>%
  drop_na(sgroup) %>% 
  ggplot(., aes((x = mpm))) +
  #geom_line(aes(x = mpm, group = fam_g, color = fam_g), stat = "density", alpha = 0.8) +
  geom_line(aes(x = mpm, group = sgroup), color = "grey",stat = "density", alpha = 0.8) +
  geom_line(stat = "density", color = "black", lwd = 1) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  labs(y = "Density", x = "Velocity in m/min") +
    # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[3]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[2], y = zoom_dims[4], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[1], xend = zoom_dims[1], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  # geom_segment(aes(x = zoom_dims[2], xend = zoom_dims[2], y = zoom_dims[3], yend = zoom_dims[4]), color = box_color) +
  theme_classic() +
  scale_color_manual(values = my.cols2) +
  theme(legend.position = "none")

fam_dens_plot +
  coord_cartesian(
    xlim = zoom_dims[1:2],
    ylim = zoom_dims[3:4]) +
  theme(title = element_blank()) -> fam_zoom


fam_dens_plot +
  annotation_custom(grob = ggplotGrob(fam_zoom), xmin = annot_xy[1] , xmax = annot_xy[2] , ymin = annot_xy[3] , ymax = annot_xy[4]) -> b

plot_grid(b, a, labels = c("A)", "B)"))

ggsave2(filename = "Ch2_distributions/Figures/Figure1_bw.png")
```  

Figure 1 - Kernel density estimates for the distribution of velocity data at different pooling levels, with the dark black density curve showing complete pooling. A) Partial pooling representation of the data, where each curve displays the density of velocities across a social group. B) No pooling scenario, where each density curve is associated to a single individual's velocity data. Plot inserts show a zoom to the tail of the distribution of velocity data in both panels. We observe considerable variation for both partial and no pooling scenarios, when compared to the single black density curve that represents the complete pooling. Particular focus towards the tails, where certain individuals possess much higher densities for large velocities, something that gets dampened when considering pooled data for velocity densities. 



<!-- # Fits  -->

```{r}
load("Ch2_distributions/Ch2_fits.RData")
```


```{r}
reg_fits_info %>% 
  dplyr::select(., dist, dBIC, ID, model) %>% 
  distinct() %>% 
  filter(., dBIC == 0) -> bestmodel

#bestmodel
```


```{r eval=FALSE}
# Difference to the second best model

reg_fits_info %>% 
  dplyr::select(., dist, dBIC, ID, model) %>% 
  distinct() %>% 
  ggplot(., aes(x = ID, y = dBIC, color = dist)) +
  #facet_wrap(~model) +
  geom_point()

```



```{r}
# Calculate the BIC for the models:

reg_fits_info %>% 
  dplyr::select(model, ID, dist, loglik, n, kpars) %>% 
  distinct() %>% 
  group_by(model, dist) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) -> A 

reg_fits_info %>% 
  filter(., model != "CP") %>% 
  dplyr::select(model, ID, dist, loglik, n, kpars, dBIC) %>% 
  distinct() %>% 
  filter(., dBIC == 0) %>% 
  group_by(model) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) %>% 
  transmute(model = model,
            dist = "Multi",
            BIC = BIC) -> B

rbind.data.frame(A, B) -> C
  

C %>%
  group_by(model) %>% 
  mutate(deltaBIC_withinmodels = signif(BIC - min(BIC), 3)) %>% 
  ungroup() %>% 
  mutate(deltaBIC_acrossmodels = signif(BIC - min(BIC), 3)) %>% 
  arrange(model) -> BIC_table
```

```{r}
cp.boot.fits %>% 
  dplyr::select(dist, bic, boot) %>% 
  distinct() %>% 
  transmute(dist = dist,
            BIC = bic,
            boot = boot,
            model = "CP") %>% 
  group_by(boot) %>% 
  mutate(., deltaBIC = signif(BIC - min(BIC), 3)) %>% 
  ungroup() -> cp.bic

pp.boot.fits %>% 
  dplyr::select(loglik, n, kpars, dist, group, boot) %>% 
  distinct() %>% 
  group_by(boot, dist) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) %>% 
  transmute(dist = dist,
            BIC = BIC,
            boot = boot,
            model = "PP") %>% 
  bind_rows(., pp.boot.fits %>% 
  dplyr::select(loglik, n, kpars, dist, group, boot, dBIC) %>% 
  distinct() %>% 
  filter(., dBIC == 0) %>% 
  group_by(boot) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) %>% 
  transmute(dist = "multi",
            BIC = BIC,
            boot = boot, 
            model = "PP")) %>% 
  group_by(boot) %>% 
  mutate(., deltaBIC = signif(BIC - min(BIC), 3)) %>% 
  ungroup() %>% 
  arrange(boot) -> pp.bic


  
np.boot.fits %>% 
  dplyr::select(loglik, n, kpars, dist, individual, boot) %>% 
  distinct() %>% 
  group_by(boot, dist) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) %>% 
  transmute(dist = dist,
            BIC = BIC,
            boot = boot,
            model = "NP") %>%   
  bind_rows(., np.boot.fits %>% 
  dplyr::select(loglik, n, kpars, dist, individual, boot, dBIC) %>% 
  distinct() %>% 
  filter(., dBIC == 0) %>% 
  group_by(boot) %>% 
  summarise(BIC = log(sum(n))*sum(kpars) - 2 * sum(loglik)) %>% 
  transmute(dist = "multi",
            BIC = BIC,
            boot = boot, 
            model = "NP")) %>% 
  group_by(boot) %>% 
  mutate(., deltaBIC = signif(BIC - min(BIC), 3)) %>% 
  ungroup() %>% 
  arrange(boot) -> np.bic



```
# Table 1 - BIC values for models across pooling levels  

Table 1 - BIC values obtained for models fitted to velocity data across pooling levels. Probability density functions considered included the Gamma, Weibull, and Lognormal distributions. Multi distribution models selected the best fitting distribution model for each family group or individual, allowing for variation not only in estimated parameters, but also in the distribution used. Based on BIC values, the best fitting model is the Multi-distribution with Partial Pooling, closely followed by the Complete Pooling Lognormal model. 


```{r}

BIC_table %>% 
  mutate(dist = ifelse(dist == "lnorm", "lognormal", dist),
         dist = str_to_title(dist)) %>% 
  mutate(model = factor(model, levels = c("CP", "PP", "NP"))) %>% 
  arrange(., model) -> BIC_table

BIC_table

```

```{r eval=FALSE}

#library(gt)

gt_tbl <- gt(BIC_table[, 2:5], rowname_col = "dist")


gt_tbl %>% 
  tab_header(
    title = md("**Model comparisons across levels**")
  ) %>% 
  tab_stubhead(label = "Model") %>% 
  tab_row_group(
    group = "NP",
    rows = 8:11
  ) %>% 
  tab_row_group(
    group = "PP",
    rows = 4:7
  ) %>% 
  tab_row_group(
    group = "CP", 
    rows = 1:3
  ) %>% 
  tab_spanner(
    label = md("**BIC**"),
    columns = vars(BIC, deltaBIC_withinmodels, deltaBIC_acrossmodels)
  ) %>% 
  cols_label(
    deltaBIC_withinmodels = html("&Delta; BIC<sub>within</sub>"),
    deltaBIC_acrossmodels = html("&Delta; BIC<sub>across</sub>"),
  ) 

# -> gt_table_bic
#   
# gtsave(gt_table_bic, "Ch2_distributions/aic_bic_table.png") 
```


```{r eval = FALSE}
knitr::include_graphics("Ch2_distributions/aic_bic_table.png")
```




# Figure 3 - Percent Support


```{r Figure3, fig.width=12, fig.height=5}

cols.fig2 <- c("#b9bec3", 
               "#0d907a", "#DEB41E", "#9C1D29", "#23262f")

cp.bic %>% 
  bind_rows(pp.bic) %>% 
  bind_rows(np.bic) %>% 
  filter(., deltaBIC == 0) %>% 
  group_by(model) %>% 
  count(dist) %>% 
  mutate(prcnt_support = n/nboots) %>%
  mutate(dist = factor(dist, levels = c("gamma", "lnorm", "weibull", "multi")),
         model = factor(model, levels = c("CP", "PP", "NP"))) %>% 
  ggplot(., aes(x = model, y = prcnt_support, fill = dist)) +
  scale_fill_manual(values = cols.fig2, drop = FALSE) +
  geom_col() +
  theme_classic() +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Pooling Level", y = "Percent Support") +
  theme(axis.title.x = element_blank()) +
  geom_label(data = bestmodel %>%
               filter(., model == "CP"),
             aes(x = model, y = -0.05, label = dist), size = 2.5) -> pooling.support

# cp.boot.fits %>%
#   dplyr::select(., bic, dist, dBIC, boot) %>%
#   group_by(boot) %>%
#   distinct() %>%
#   ungroup() %>%
#   filter(dBIC == 0) %>%
#   count(dist) %>%
#   mutate(prcnt_support = n/nboots) %>%
#   mutate(model = "CP") %>%
#   ggplot(., aes(x = model, y = prcnt_support, fill = dist)) +
#   geom_col() +
#   labs(y = "Percent Support") +
#   theme_classic() +
#   theme(legend.position = "none",
#         axis.title.x = element_blank()) +
#   geom_label(data = bestmodel %>% filter(., model == "CP"),
#              aes(x = model, y = -0.05, label = dist)) +
#   scale_fill_manual(values = cols.fig2) -> cp.fit

pp.boot.fits %>%
  dplyr::select(., bic, dist, dBIC, group, boot) %>%
  group_by(group, boot) %>%
  distinct() %>%
  group_by(group) %>%
  filter(dBIC == 0) %>%
  count(dist) %>%
  mutate(prcnt_support = n/nboots) %>%
  ggplot(., aes(x = group, y = prcnt_support, fill = dist)) +
  geom_col() +
  theme_classic() +
  theme(legend.position = "none",
        axis.title.y = element_blank(),
        axis.title.x = element_blank()) +
  scale_y_continuous(labels = scales::percent) +
  geom_label(data = bestmodel %>% filter(., model == "PP"),
             aes(x = ID, y = -0.05, label = dist), size = 2.5) +
  scale_fill_manual(values = cols.fig2) -> pp.support

np.boot.fits %>%
  dplyr::select(., bic, dist, dBIC, individual, boot) %>%
  group_by(individual, boot) %>%
  distinct() %>%
  group_by(individual) %>%
  filter(dBIC == 0) %>%
  count(dist) %>%
  mutate(prcnt_support = n/nboots,
         individual = factor(individual, levels = c("B1", "B3", "B5", "B7", "B13", "B19", "B22", "B28", "B49", "B84", "B30", "B29"))) %>%
  ggplot(., aes(x = individual, y = prcnt_support, fill = dist)) +
  geom_col() +
  theme_classic() +
  theme(axis.title.y = element_blank(),
        axis.title.x = element_blank()) +
  scale_y_continuous(labels = scales::percent) +
  geom_label(data = bestmodel %>% filter(., model == "NP"),
             aes(x = ID, y = -0.05, label = dist), size = 2.5) +
  scale_fill_manual(values = cols.fig2)  -> np.support

# legend <- get_legend(np.fit + theme(legend.position = "bottom") +
#                        guides(fill=guide_legend(title="Distribution")))
model.legend <- get_legend(pooling.support + theme(legend.position = "bottom") +
                             guides(fill=guide_legend(title = "Distribution model")))

# plot_grid(cp.fit, pp.fit, 
#           np.fit + theme(legend.position = "none"), 
#           ncol = 3, rel_widths = c(0.8,1,1.4)) -> col_grid
# 
# plot_grid(col_grid, legend, nrow = 2, rel_heights = c(1, 0.1))

# first_row <- plot_grid(NULL, 
#                        pooling.support + theme(legend.position = "none"),
#                        NULL, rel_widths = c(0.3, 1, 0.3))
# 
# second_row <- plot_grid(pp.support, 
#                         np.support + theme(legend.position = "none"),
#                         ncol = 2, rel_widths = c(1, 1.2))
# plot_grid(pooling.support + theme(legend.position = "none"),
#           second_row, model.legend, nrow = 3, rel_heights = c(1,1,0.2))


bar_col <- plot_grid(pooling.support + theme(legend.position = "none"),
                     pp.support, 
                     np.support + theme(legend.position = "none"),
                     ncol = 3, rel_widths = c(0.4, 1, 1.4), 
                     labels = c("A)", "B)", "C)"), label_size = 10)
plot_grid(bar_col, model.legend, nrow = 2, rel_heights = c(1, 0.1))

ggsave2(filename = "Ch2_distributions/Figures/Figure3.png")

```   

Figure 3 - Percent support for the different distribution models at the three pooling levels. Percent support is based on 1000 bootstrapped replicas for each scenario. Labels on the x axis show the best fitting model for the original datasets. A) percent support at the three pooling levels, with CP having over 50% support for the lognormal distribution, in agreement with the model fit to the complete dataset. PP and NP scenarios show 100% support for the multi-distribution model, which considers the best fitting model for each family group or individual, respectively. B) Percent support for each model in the family groups. C) Support for each model at the individual level.  


```{r eval=FALSE}
# These boxplots should be showing the distribution of the BIC values for the three pooling levels with their models. 

cp.bic %>% 
  bind_rows(pp.bic) %>% 
  bind_rows(np.bic) %>% 
  mutate(dist = factor(dist, levels = c("gamma", "lnorm", "weibull", "multi"))) %>% 
  ggplot(., aes(x = model, color = dist, y = BIC)) +
  geom_boxplot() +
  scale_color_manual(values = cols.fig2) +
  labs(x = "Pooling Model", y = "Raw BIC values") +
  theme_classic() +
  guides(color=guide_legend(title = "Distribution model")) +
  theme(legend.position = "bottom")

``` 



# Figure 4 - BIC units from best model

<!-- Fix this. The idea is that each bootstrap is represented here with their BIC value for each model. We see that there's very strong evidence for the multi distribution model at both PP and NP levels. The summary quantiles later show very high support for this. Difference here between incorporating variation at the expense of sample size, and getting high support, or staying with high sample size without variation. -->



```{r eval=FALSE, fig.height=4}

cp.bic %>% 
  mutate(dist = factor(dist, levels = c("gamma", "lnorm", "weibull", "multi"))) %>% 
  ggplot(., aes(x = deltaBIC, color = dist, y = boot)) +
  #geom_col() +
  geom_point(alpha = 0.8, shape = 15) +
  scale_color_manual(values = cols.fig2) +
  theme_classic() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(y = "Bootstrap \n replicates", x = "") +
  theme(legend.position = "none") -> Fig4a

pp.bic %>% 
  mutate(dist = factor(dist, levels = c("gamma", "lnorm", "weibull", "multi"))) %>% 
  ggplot(., aes(x = deltaBIC, color = dist, y = boot)) +
  #geom_col() +
  geom_point(alpha = 0.8, shape = 15) +
  scale_color_manual(values = cols.fig2) +
  theme_classic() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(y = "Bootstrap \n replicates", x = "") +
  theme(legend.position = "none") -> Fig4b

np.bic %>% 
  mutate(dist = factor(dist, levels = c("gamma", "lnorm", "weibull", "multi"))) %>% 
  ggplot(., aes(x = deltaBIC, color = dist, y = boot)) +
  #geom_col() +
  geom_point(alpha = 0.8, shape = 15) +
  scale_color_manual(values = cols.fig2) +
  theme_classic() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(y = "Bootstrap \n replicates", x = "BIC units from best model") -> Fig4c

legend4 <- get_legend(Fig4c +
                       guides(color=guide_legend(title = "Distribution \n model")))

plot_grid(Fig4a, Fig4b, 
          Fig4c + theme(legend.position = "none"), nrow = 3) -> fig4

plot_grid(fig4, legend4, ncol = 2, rel_widths = c(1, 0.15))

```


```{r fig.height=4}
cp.bic %>% 
  bind_rows(., pp.bic) %>% 
  bind_rows(., np.bic) %>% 
  mutate(dist = factor(dist, levels = c("gamma", "lnorm", "weibull", "multi")),
         model = factor(model, levels = c("CP", "PP", "NP"))) %>% 
  ggplot(., aes(x = deltaBIC, color = dist, y = boot)) +
  facet_wrap(~model, nrow = 3) +
  #geom_col() +
  geom_point(alpha = 0.8, shape = 15, size = 0.8) +
  scale_color_manual(values = cols.fig2) +
  theme_classic() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(y = "Bootstrap replicates", x = "BIC units from best model") +
  theme(legend.position = "right") +
  guides(color=guide_legend(title = "Distribution \n model")) 

ggsave2(filename = "Ch2_distributions/Figures/Figure4.png")
``` 

Figure 4 - Delta BIC values for each bootstrap in the three pooling scenarios. Each bootstrap is represented in the y axis, with BIC units from the best model shown in the x axis. For the first panel, the CP scenario shows significant overlap among models for each bootstrap. Given that multi distribution models for the PP and NP scenarios have 100% support, this means they have the lowest BIC score, or a $\Delta$ BIC equal to zero, and thus show as a straight line at x=0 in the plots above.


# Table 2 - Average BIC units from best model

Table 2 - Mean and median distance for second best model in BIC units, for each of the pooling scenarios.

```{r Table2}
# cp.bic %>% 
#   filter(., deltaBIC != 0) %>% 
#   group_by(boot) %>% 
#   summarise(min = min(deltaBIC)) %>% 
#   summary()
# 
# pp.bic %>% 
#   filter(., deltaBIC != 0) %>% 
#   group_by(boot) %>% 
#   summarise(min = min(deltaBIC)) %>% 
#   summary()
# 
# np.bic %>% 
#   filter(., deltaBIC != 0) %>% 
#   group_by(boot) %>% 
#   summarise(min = min(deltaBIC)) %>% 
#   summary()


cp.bic %>% 
  bind_rows(pp.bic) %>% 
  bind_rows(np.bic) %>% 
  filter(., deltaBIC != 0) %>% 
  mutate(model = factor(model, levels = c("CP", "PP", "NP"))) %>% 
  group_by(model, boot) %>% 
  summarise(min = min(deltaBIC)) %>% 
  group_by(model) %>% 
  summarise(minimum = min(min),
            median = median(min),
            mean = mean(min))

```


# Figure X - Best fit parameters

To tell the same story, we see variation in the parameters estimated for each bootstrap under various models.  


```{r}

cp.boot.fits %>%
  filter(., dBIC == 0) %>% 
  dplyr::select(boot, estimate, param, dist) %>% 
  pivot_wider(names_from = param, values_from = estimate) -> cp.best


pp.boot.fits %>%
  filter(., dBIC == 0) %>% 
  dplyr::select(group, boot, estimate, param, dist) %>% 
  pivot_wider(names_from = param, values_from = estimate) %>% 
  mutate(group = as.factor(group)) -> pp.best

np.boot.fits %>%
  filter(., dBIC == 0) %>% 
  dplyr::select(individual, boot, estimate, param, dist) %>% 
  pivot_wider(names_from = param, values_from = estimate) %>% 
  mutate(id = str_remove(individual, "B"), 
         group = case_when(
    id %in% c(1,3,5) ~ "G1",
    id %in% c(7) ~ "G2",
    id %in% c(13, 19) ~ "G3",
    id %in% c(22) ~ "G4",
    id %in% c(28) ~ "G5",
    id %in% c(49, 84) ~ "G6",
    id %in% c(29, 30) ~ "G7"
  )) %>%
  #slice_sample(., n = 100) %>%
  mutate(group = as.factor(group)) %>% 
  arrange(group) %>% 
  group_by(group) %>% 
  mutate(shapeid = as.character(as.numeric(as.factor(individual)))) -> np.best
#View(np.best)


# What values to use
# map_dbl(cp.best[,-c(1,2)], min, na.rm = TRUE)
# map_dbl(cp.best[,-c(1,2)], max, na.rm = TRUE)
# map_dbl(pp.best[,-c(1:3)], min, na.rm = TRUE)
# map_dbl(pp.best[,-c(1:3)], max, na.rm = TRUE)
# map_dbl(np.best[,c(4:8)], min, na.rm = TRUE)
# map_dbl(np.best[,c(4:8)], max, na.rm = TRUE)

```


```{r FigureX, fig.height=9, fig.width=9}

colsx <- met.brewer("Tiepolo", n = 7)
aval <- 0.3

figx.theme <- theme_bw() +
  theme(legend.position = "none",
        axis.title = element_text(size = 8))

cp.best %>% 
  filter(., dist == "lnorm") %>% 
  ggplot(., aes(x = meanlog, y = sdlog)) +
  geom_point(alpha = aval) +
  lims(x = c(0.7, 3.7), y = c(0.5, 2.1)) +
  labs(subtitle = "CP - lnorm") +
  figx.theme -> cp.ln

cp.best %>%
  filter(., dist == "weibull") %>% 
  ggplot(., aes(x = scale, y = shape)) +
  geom_point(alpha = aval) +
  lims(x = c(5, 80), y = c(0, 2.1)) +
  labs(subtitle = "CP - weibull") +
  figx.theme -> cp.wei

cp.grid <- plot_grid(cp.ln, cp.wei, ncol = 2, labels = c("A)", "B)"), label_size = 9)

pp.best %>% 
  filter(., dist == "gamma") %>% 
  ggplot(., aes(x = rate, y = shape, color = group)) +
  geom_point(alpha = aval) +
  scale_color_manual(values=colsx, drop=FALSE) +
  lims(x = c(0, 0.23), y = c(0.4, 2.3)) +
  labs(subtitle = "PP - gamma") +
  figx.theme -> pp.gam

pp.best %>%
  filter(., dist == "lnorm") %>% 
  ggplot(., aes(x = meanlog, y = sdlog, color = group)) +
  geom_point(alpha = aval) +
  scale_color_manual(values=colsx, drop=FALSE) +
  lims(x = c(0.7, 3.7), y = c(0.5, 2.1)) +
  labs(subtitle = "PP - lnorm") +
  figx.theme -> pp.ln

pp.best %>%
  filter(., dist == "weibull") %>% 
  ggplot(., aes(x = scale, y = shape, color = group)) +
  geom_point(alpha = aval) +
  scale_color_manual(values=colsx, drop=FALSE) +
  lims(x = c(5, 80), y = c(0, 2.1)) +
  labs(subtitle = "PP - weibull") +
  figx.theme -> pp.wei

pp.grid <- plot_grid(pp.gam, pp.ln, pp.wei, nrow = 1, labels = c("C)", "D)", "E)"), label_size = 9)


np.best %>% 
  filter(., dist == "gamma") %>% 
  ggplot(., aes(x = rate, y = shape, color = group, shape = shapeid)) +
  geom_point(alpha = aval) +
  scale_color_manual(values=colsx, drop=FALSE) +
  lims(x = c(0, 0.23), y = c(0.4, 2.3)) +
  labs(subtitle = "NP - gamma") +
  figx.theme -> np.gam

np.best %>% 
  filter(., dist == "lnorm") %>% 
  ggplot(., aes(x = meanlog, y = sdlog, color = group, shape = shapeid)) +
  geom_point(alpha = aval) +
  scale_color_manual(values=colsx, drop=FALSE) +
  lims(x = c(0.7, 3.7), y = c(0.5, 2.1)) +
  labs(subtitle = "NP - lnorm") +
  figx.theme -> np.ln

np.best %>%
  filter(., dist == "weibull") %>% 
  ggplot(., aes(x = scale, y = shape, color = group, shape = shapeid)) +
  geom_point(alpha = aval) +
  scale_color_manual(values=colsx, drop=FALSE) +
  lims(x = c(5, 80), y = c(0, 2.1)) +
  labs(subtitle = "NP - weibull") +
  figx.theme -> np.wei

np.grid <- plot_grid(np.gam, np.ln, np.wei, nrow = 1, labels = c("F)", "G)", "H)"), label_size = 9)


legend.grid <- get_legend(pp.best %>%
  filter(., dist == "lnorm") %>% 
  ggplot(., aes(x = meanlog, y = sdlog, color = group)) +
  geom_point(alpha = aval) +
  scale_color_manual(values=colsx) +
  lims(x = c(0.7, 3.7), y = c(0.5, 2.1)) +
  theme_bw() +
  guides(color = guide_legend(title = "Social Group", ncol = 2,
                              override.aes = list(alpha = 0.9, size = 5))))

#cp.grid <- plot_grid(legend.grid, cp.ln, cp.wei, ncol = 3)
row1 <- plot_grid(legend.grid, cp.grid, ncol = 2, rel_widths = c(1,2))

plot_grid(row1, pp.grid, np.grid, nrow = 3)

ggsave2(filename = "Ch2_distributions/Figures/Figurex.png")
```



# Figure X - angles

```{r fig.width=8, fig.height=6, eval = FALSE}
p1_angles <- ptpl %>% 
  drop_na(rel.angle) %>% 
  mutate(d.angle = ifelse(rel.angle > 0, rel.angle * 180/pi,
                          rel.angle * 180/pi + 360)) %>% 
  ggplot(., aes(x = d.angle)) +
  geom_histogram(color = "grey", fill = "grey") +
  coord_polar(theta = "x", start = -pi/2, direction = -1) +
  scale_x_continuous(breaks = seq(0, 360, 30), limits = c(0, 360)) +
  theme_minimal() +
  theme(axis.title = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none") +
  labs(title = "Complete pooling")


p2_angles <- ptpl %>% 
  drop_na(rel.angle) %>% 
  mutate(d.angle = ifelse(rel.angle > 0, rel.angle * 180/pi,
                          rel.angle * 180/pi + 360)) %>% 
  ggplot(., aes(x = d.angle)) +
  geom_histogram(color = "grey", fill = "grey") +
  coord_polar(theta = "x", start = -pi/2, direction = -1) +
  scale_x_continuous(breaks = seq(0, 360, 30), limits = c(0, 360)) +
  theme_minimal() +
  theme(axis.title = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none") +
  facet_wrap(~group, nrow = 2) +
  theme(axis.text = element_blank()) +
  labs(title = "Partial pooling")

p3_angles <- ptpl %>% 
  drop_na(rel.angle) %>% 
  mutate(d.angle = ifelse(rel.angle > 0, rel.angle * 180/pi,
                          rel.angle * 180/pi + 360),
         B_id = paste0("B", id)) %>% 
  ggplot(., aes(x = d.angle)) +
  geom_histogram(color = "grey", fill = "grey") +
  coord_polar(theta = "x", start = -pi/2, direction = -1) +
  scale_x_continuous(breaks = seq(0, 360, 30), limits = c(0, 360)) +
  theme_minimal() +
  theme(axis.title = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none") +
  facet_wrap(~B_id, nrow = 2) +
  theme(axis.text = element_blank()) +
  labs(title = "No pooling")

plot_grid(plot_grid(p1_angles, p2_angles), p3_angles, nrow = 2)

```


