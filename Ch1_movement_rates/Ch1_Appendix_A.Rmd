---
title: "Implications of animal movement rate variation in spatial patterns of seed dispersal"
author: "Javiera Rudolph"
date: "8/12/2021"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
knitr::opts_chunk$set(fig.width=12, fig.height=6) 
```

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(cowplot)
library(fitdistrplus)
library(Hmisc)
```


Let's say there is a variation in animal movement rates, and it depends on multiple factors, such as size of the animal, breeding status, nesting, etc. So, it can also be seasonal. Since movement rates can't really be negative, we will use a lognormal distribution to describe this variation in movement rates among individuals from a population.

Let $X_i$ be a positive random variable that is log-normally distributed $(i.e. X_i \sim Lognormal(\mu_i, \sigma_i^2)$ describing the distribution of movement rates for an animal population $i$. Such population's average movement rate being $\mu_i$ and the variance of their movement rates $\sigma_i^2$. These average movement rates can depend on homerange size for example, or seasonality (i.e. breeding, nesting, etc.). We will assume we have three different populations, where perhaps some of them have larger home ranges, creating more variance across movement rates. To make things a little easier, we will consider all populations have the same average movement rate $(i.e. \mu_1=\mu_1=\mu_3 = 1)$, but different standard deviation $(\sigma_1=0.3, \sigma_2=0.5, \sigma_3=0.5)$. Note that variance, $\sigma^2$ is the square of standard deviation, $\sigma$. We can visualize the distribution of movement rates for each of these populations: 

```{r}
set.seed(98)

av.mov.rate <- 1
max.x <- 10

mycols <- c("red", "green", "blue")
#create density plots
curve(dlnorm(x, meanlog=av.mov.rate, sdlog=0.3),
      from=0, to=max.x,
      col=mycols[1],
      main = 'Log Normally distributed movement rates for three populations', #add title
      ylab = 'Density', #change y-axis label
      )

curve(dlnorm(x, meanlog=av.mov.rate, sdlog=0.5), 
      from=0, to=max.x,
      col=mycols[2], add=TRUE)

curve(dlnorm(x, meanlog=av.mov.rate, sdlog=1), 
      from=0, to=max.x,
      col=mycols[3], add=TRUE)

#add legend
legend("topright", legend=c("sdlog=.3", "sdlog=.5", "sdlog=1"),
       col=mycols, lty=1, cex=1.2)
```


Now, lets sample a movement rate, $m$, for 5 individuals $(i.e. j = 1, ...,5)$ from the first population $(i.e. m_{1,j} = m_{1,1}, ....., m_{1,5})$. We will simulate animal movement with a simple random walk, with movement length $l$ sampled from an exponential distribution, $l \sim exp(m_{i,j})$, and movement angle, $\theta$, from a uniform distribution, $\theta \sim U(0, 360)$.

```{r}
n.individuals <- 5
m_1 <- sort(round(rlnorm(n.individuals, meanlog = av.mov.rate, sdlog = 0.3),3))
m_2 <- sort(round(rlnorm(n.individuals, meanlog = av.mov.rate, sdlog = 0.5),3))
m_3 <- sort(round(rlnorm(n.individuals, meanlog = av.mov.rate, sdlog = 1),3))
```

We can look at how those exponential distributions look for each of the individuals in those populations. Each curve describes the distribution of movement lengths for each of the five individuals in the population. Each panel represents one of the populations.

```{r fig.width=12}

par(mfrow=c(1,3))
mycols <- rainbow(n.individuals, s=1)

range <- c(-0.1,max.x+5)
#create density plots
#########################################################################
# Fist population
curve(dexp(x, 1/m_1[1]), #notice rate for exponential is 1/movement rate.
      from=range[1], to=range[2], 
      col=mycols[1],
      main = 'Distribution of movement lengths', #add title
      ylab = 'Density', #change y-axis label
      xlab = "x"
      )
for(i in 2:5){
  curve(dexp(x, 1/m_1[i]), 
        from=range[1], to=range[2],
        col=mycols[i], add=TRUE)
}

#add legend
legend("topright", legend= m_1,
       col=mycols, lty=1, cex=1.2)
#########################################################################
# Second population
curve(dexp(x, 1/m_2[1]), #notice rate for exponential is 1/movement rate.
      from=range[1], to=range[2], 
      col=mycols[1],
      main = 'Distribution of movement lengths', #add title
      ylab = 'Density', #change y-axis label
      xlab = "x"
      )
for(i in 2:5){
  curve(dexp(x, 1/m_2[i]), 
        from=range[1], to=range[2],
        col=mycols[i], add=TRUE)
}

#add legend
legend("topright", legend= m_2,
       col=mycols, lty=1, cex=1.2)

#########################################################################
# Third population
curve(dexp(x, 1/m_3[1]), #notice rate for exponential is 1/movement rate.
      from=range[1], to=range[2], 
      col=mycols[1],
      main = 'Distribution of movement lengths', #add title
      ylab = 'Density', #change y-axis label
      xlab = "x"
      )
for(i in 2:5){
  curve(dexp(x, 1/m_3[i]), 
        from=range[1], to=range[2],
        col=mycols[i], add=TRUE)
}

#add legend
legend("topright", legend= m_3,
       col=mycols, lty=1, cex=1.2)
```



```{r eval=FALSE}
t <- 100 # Number of time steps
individual <- 5

tru.rate <- m_1[individual] # In case I want to do scale 1/rate
movedist <- rexp(t, rate = 1/tru.rate)
angle <- runif(t, min = 0, max = 360)
distx <- movedist*cos(angle)
xloc <- c(0, cumsum(distx))
disty <- movedist*sin(angle)
yloc <- c(0, cumsum(disty))
animalTraj <- data.frame(time = 0:t, xloc = xloc, yloc = yloc)

plot(x = xloc, y = yloc, col = mycols[individual], type = "l", main = paste("Rate", tru.rate))

```

```{r}
sim_movement <- function(prm, t = 1000, plot.it = TRUE, return.data.frame = FALSE){
  tru.rate <- round(prm, 3)
  movedist <- rexp(t, rate = 1/tru.rate)
  angle <- runif(t, min = 0, max = 360)
  distx <- movedist*cos(angle)
  xloc <- c(0, cumsum(distx))
  disty <- movedist*sin(angle)
  yloc <- c(0, cumsum(disty))
  animalTraj <- data.frame(time = 0:t, xloc = xloc, yloc = yloc)
  if(plot.it == TRUE){
    plot(x = xloc, y = yloc, type = "l", main = paste("Rate=",tru.rate))
  }
  if(return.data.frame == TRUE){
    return(animalTraj)
  }
}
```

```{r eval=FALSE}
par(mfrow=c(2,5))

for(j in 1:individual){
  sim_movement(m_1[j])}

```

```{r eval=FALSE}

df <- sim_movement(m_1[1], plot.it = FALSE, return.data.frame = TRUE)

df %>% 
  ggplot(., aes(x = xloc, y=yloc)) +
  geom_path()

```

## Individual movement
For each population, we can simulate the movement of every individual using a random walk. Colors correspond to the individuals in the plot above. Every individual is sorted based on their average movement rate, so that the first individuals, colored in red, correspond to the smallest movement rate. In contrast, individuals described by violet correspond to the individuals with the highest movement rate in that population.
```{r eval=FALSE}
nruns <- 3
# Population1
df <- NULL

for(j in 1:n.individuals){
  for(k in 1:nruns){
  a <- sim_movement(m_1[j], plot.it = FALSE, return.data.frame = TRUE) %>% 
    mutate(indiv = as.factor(j),
           run = paste("r_", k))
  df <- rbind.data.frame(df, a)
}
}
  

df %>% 
  ggplot(., aes(x = xloc, y=yloc, group = run, color = indiv)) +
  geom_path() +
  scale_color_manual(values = mycols) +
  theme_bw()

# Population2
df <- NULL

for(j in 1:n.individuals){
  for(k in 1:nruns){
  a <- sim_movement(m_2[j], plot.it = FALSE, return.data.frame = TRUE) %>% 
    mutate(indiv = as.factor(j),
           run = paste("r_", k))
  df <- rbind.data.frame(df, a)
}
}
  

df %>% 
  ggplot(., aes(x = xloc, y=yloc, group = run, color = indiv)) +
  geom_path() +
  scale_color_manual(values = mycols) +
  theme_bw()

# Population3
df <- NULL

for(j in 1:n.individuals){
  for(k in 1:nruns){
  a <- sim_movement(m_3[j], plot.it = FALSE, return.data.frame = TRUE) %>% 
    mutate(indiv = as.factor(j),
           run = paste("r_", k))
  df <- rbind.data.frame(df, a)
}
}
  

df %>% 
  ggplot(., aes(x = xloc, y=yloc, group = run, color = indiv)) +
  geom_path() +
  scale_color_manual(values = mycols) +
  theme_bw()
```


```{r}
nruns <- 3
m.data <- data.frame(m_1, m_2, m_3)

df <- NULL

for(m in 1:3){
  m.0 <- m.data[m]
  for(j in 1:n.individuals){
  for(k in 1:nruns){
  a <- sim_movement(m_2[j], plot.it = FALSE, return.data.frame = TRUE) %>% 
    mutate(indiv = as.factor(j),
           run = paste0("r_", k),
           pop.id = paste0("p_",m))
  df <- rbind.data.frame(df, a)
}
}
  
}


df %>% 
  ggplot(., aes(x = xloc, y=yloc, group = run, color = indiv)) +
  facet_wrap(~pop.id) +
  geom_path() +
  scale_color_manual(values = mycols) +
  theme_bw() +
  theme(legend.position = "bottom") +
  NULL
```


## Example individual
### Simulate movement and seed droppings  

Now, we get the animals to disperse seeds. To do this, we combine seed gut retention times and animal movement. We can visualize this for one individual. Each simulation run consists of the animal disperser starting at point (0,0) and getting a number of seeds, each of which has an associated gut retention time $(grt \sim Gamma(4,5))$. The simulation run ends once all seeds have dropped. For that run, we calculate the average seed location by taking the average of x and y coordinates of all seeds. We also calculate seed dispersion as a measure of how close to each other or how scattered the seeds are for that run.
```{r eval=FALSE}
nseeds <- 20
grt <- round(rgamma(nseeds, shape = 4, scale = 5))
t.grt <- max(grt)

animalTraj <- sim_movement(m_1[1], t = t.grt, plot.it = FALSE, return.data.frame = TRUE)

animalTraj %>% 
  left_join(., data.frame(s.id = 1:nseeds, time = grt), by = "time") %>% 
  mutate(disp = sqrt(xloc^2+yloc^2)) -> df

df %>% 
  drop_na(s.id) %>% 
  mutate(xi = (mean(xloc)-xloc)^2,
         yi = (mean(yloc)-yloc)^2) %>% 
  summarise(x = mean(xloc),
            y = mean(yloc),
            av.disp = mean(disp),
            se.disp = sd(disp)/sqrt(n()),
            dsprsn = sum(sqrt(xi+yi))/n()) -> s.df


# Calculate the mean location of seeds
x_m <- mean(seed_loc$xloc)
y_m <- mean(seed_loc$yloc)
mean_dispersal <- mean(seed_loc$dispersal)
se_dispersal <- sd(seed_loc$dispersal)/sqrt(length(seed_loc$dispersal))

# Calculate seed dispersion
xi <- (x_m - seed_loc$xloc)^2
yi <- (y_m - seed_loc$yloc)^2
seed_dispersion <- sum(sqrt(xi + yi))/length(seed_loc$time)

df %>% 
  ggplot(., aes(x = xloc, y=yloc)) +
  geom_path() +
  geom_point(data = df %>% drop_na(s.id), 
             aes(x = xloc, y = yloc)) +
  geom_point(data = s.df,
             aes(x = x, y = y), color = "Red") # Mean location of seeds

```

```{r}
sim_seeds <- function(nseeds = 20, m.prms = NULL,...){
  grt <- round(rgamma(nseeds, shape = 4, scale = 5))
  t.grt <- max(grt)

  df <- sim_movement(m.prms, t = t.grt, plot.it = FALSE, return.data.frame = TRUE)

  df %>% 
    left_join(., data.frame(s.id = 1:nseeds, time = grt), by = "time") %>% 
    mutate(disp = sqrt(xloc^2+yloc^2)) -> df
  
  return(df)
}

summ_seeds <- function(df = NULL){
  df %>% 
  drop_na(s.id) %>% 
  mutate(xi = (mean(xloc)-xloc)^2,
         yi = (mean(yloc)-yloc)^2) %>% 
  summarise(x = mean(xloc),
            y = mean(yloc),
            av.disp = mean(disp),
            se.disp = sd(disp)/sqrt(n()),
            dsprsn = sum(sqrt(xi+yi))/n()) -> s.df
  return(s.df)
}

# a <- sim_seeds(m.prms = m_1[1])
# summ_seeds(a)
```

```{r message=FALSE}
nruns <- 100
ex.i <- 1
df <- NULL
summ.df <- NULL

for(j in 1:ex.i){
  for(k in 1:nruns){
    a <- sim_seeds(m.prms = m_1[j]) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    b <- summ_seeds(a) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    df <- rbind.data.frame(df, a) 
    summ.df <- rbind.data.frame(summ.df, b) 
}
}
```

```{r}

df %>% 
  ggplot(., aes(x = xloc, y=yloc, 
                group = run,
                color = indiv)) +
  # facet_wrap(~run) +
  geom_path() +
  scale_color_manual(values = mycols) +
  geom_point(data = df %>% drop_na(s.id), 
             aes(x = xloc, y = yloc)) +
  geom_point(data = summ.df, aes(x = x, y=y), color = "black") +
  theme_bw() +
  labs(title = "Animal seed droppings", caption = "Lines show an individual's trajectory.\n Red dots show all seed droppings.\n Black dots show average location of seed per run") +
  theme(legend.position = "none") -> p1
# p1

df %>% 
  ggplot(., aes(x = xloc, y = yloc)) +
  # stat_density_2d(aes(fill = ..level..), geom = "polygon", colour="white") +
  geom_bin2d() +
  # geom_hex() +
  # scale_fill_continuous(type = "viridis") +
  scale_fill_gradient(low = "grey", high = "black") +
  # geom_point(data = df %>% drop_na(s.id), 
  #            aes(x = xloc, y = yloc), color = mycols[ex.i], alpha = 0.3) +
  # geom_point(data = summ.df, aes(x = x, y=y), color = "black") +
  theme_bw() +
  theme(legend.position = "bottom") +
  labs(title = "Density of animal movement") -> p2
# p2

cowplot::plot_grid(p1, p2)
  
# summ.df %>% 
#   ggplot(., aes(y = dsprsn)) +
#   geom_boxplot()
# 
# summ.df %>% 
#   ggplot(., aes(x = av.disp)) +
#   geom_density(color = "blue") + # for the average dispersal per run
#   geom_density(data = df %>% drop_na(s.id),
#                  aes(x = disp)) + # for every seed
#   theme_bw()
```
### Fit distribution function to seed dispersal data  

The end goal here is to understand how variation in animal movement rates can impact seed dispersal patterns. To get a metric of this seed dispersal, we fit a weibull distribution to the seed dispersal data generated by the previous simulation. Every run has 20 seeds, and we did this 100 times, thus we randomly sample 50 seeds to fit a Weibull distribution and get an approximated seed dispersal kernel.


```{r message=FALSE, warning=FALSE, echo=FALSE, results='hide'}
# s.df <- df %>% drop_na(s.id)

s.df <- df %>% drop_na(s.id) %>% 
  sample_n(., 50)
  


g <- fitdist(s.df$disp, distr = "weibull")
```

```{r}
summary(g)
plot(g)

# library(MASS)
# fitdistr(s.df$disp, densfun = "weibull")
```

# Simulation for population 1
```{r message=FALSE}
nruns <- 20

df <- NULL
summ.df <- NULL

for(j in 1:n.individuals){
  for(k in 1:nruns){
    a <- sim_seeds(m.prms = m_1[j]) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    b <- summ_seeds(a) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    df <- rbind.data.frame(df, a) 
    summ.df <- rbind.data.frame(summ.df, b) 
}
}
```

Visualize animal movement and seed dispersal. It is kind of obvious, but individuals that move further away, also disperse seeds further away and scatter them more. Red points are every seed dispersed, black points show the average seed location per run. Each panel corresponds to one individual disperser.
```{r}
df %>% 
  ggplot(., aes(x = xloc, y = yloc)) +
  facet_wrap(~indiv) +
  # stat_density_2d(aes(fill = ..level..), geom = "polygon", colour="white") +
  geom_bin2d() +
  # geom_hex() +
  # scale_fill_continuous(type = "viridis") +
  scale_fill_gradient(low = "grey", high = "black") +
  geom_point(data = df %>% drop_na(s.id),
             aes(x = xloc, y = yloc), color = "red", alpha = 0.3) +
  geom_point(data = summ.df, aes(x = x, y=y), color = "black") +
  theme_bw()
```

Seed dispersal kernels produced by each individual.
```{r}
df %>% 
  drop_na(s.id) %>% 
  ggplot(., aes(x = disp, color = indiv)) +
  geom_density() +
  scale_color_manual(values = mycols) +
  theme_bw()

```

Dispersion. We calculate dispersion for every simulated run. Every run means an individual disperser gets 20 seeds, they move until they drop all seeds. Then, dispersion measures how far away from each other every seed is. 
```{r}
summ.df %>% 
  ggplot(., aes(y = dsprsn, x = indiv, color = indiv)) +
  geom_boxplot() +
  geom_point(color = "grey", alpha = 0.5) +
  labs(title = "Dispersion") +
  theme_bw() +
  theme(legend.position = "none") -> p1
# p1

summ.df %>% 
  ggplot(., aes(y = av.disp, x = indiv, color = indiv)) +
  geom_boxplot() +
  geom_point(color = "grey", alpha = 0.5) +
  labs(title = "Average dispersal per run") +
  theme_bw() +
  theme(legend.position = "none") -> p2
# p2

plot_grid(p1, p2)
```
```{r eval=FALSE}
# Sample once for estimating parameters
s.df <- df %>% drop_na(s.id) %>%
  group_by(indiv) %>%
  sample_n(., 50)

# s.df <- df %>% drop_na(s.id)

weib.fits <- NULL

for(i in 1:n.individuals){
  dat <- s.df %>% 
    filter(indiv == i)
  #g <- fitdist(dat$disp, distr = "weibull", method = 'mle', lower = c(0,0))
  g <- fitdistr(dat$disp, densfun = "weibull", lower = c(0,0))
  prms.weib <- data.frame(est.shape = as.numeric(g$estimate[1]),
                          est.scale = as.numeric(g$estimate[2]),
                          loglik = g$loglik, indiv = i)
  weib.fits <- rbind.data.frame(weib.fits, prms.weib)
  # plot(g)
}

weib.fits
```

Bootstrapping?  
Since there are hundreds or thousands of seeds getting dispersed between all the simulations, we will randomly sample seeds and fit a weibull distribution to generate the seed dispersal kernels. The visualization shows the parameters estimated for each bootstrap, for each individual (no pooling) or when we pool all the seed dispersal data (complete pooling).
```{r}
n.boots <- 10
samp.size <- 30
weib.boot <- NULL

for(j in 1:n.boots){
      s.df <- df %>% drop_na(s.id) %>%
      group_by(indiv) %>%
      sample_n(., samp.size)
    
    # s.df <- df %>% drop_na(s.id)
    
    weib.fits <- NULL
    
    for(i in 1:n.individuals){
      dat <- s.df %>% 
        filter(indiv == i)
      #g <- fitdist(dat$disp, distr = "weibull", method = 'mle', lower = c(0,0))
      g <- fitdistr(dat$disp, densfun = "weibull", lower = c(0,0))
      prms.weib <- data.frame(est.shape = as.numeric(g$estimate[1]),
                              est.scale = as.numeric(g$estimate[2]),
                              loglik = g$loglik, indiv = i)
      weib.fits <- rbind.data.frame(weib.fits, prms.weib)
      # plot(g)
    }
    
    weib.boot <- rbind.data.frame(weib.boot, weib.fits %>% mutate(boot = j))
}

# weib.boot
```

```{r eval=FALSE}

weib.boot %>% 
  ggplot(., aes(x = factor(indiv), y = est.shape, color = factor(indiv))) +
  geom_violin() +
  scale_color_manual(values = mycols) +
  #geom_boxplot(width = 0.1) +
  stat_summary(fun.data=mean_sdl, mult=1, 
                 geom="pointrange", color="black") +
  labs(title = "Shape") +
  theme_bw() -> p1

weib.boot %>% 
  ggplot(., aes(x = factor(indiv), y = est.scale, color = factor(indiv))) +
  geom_violin() +
  scale_color_manual(values = mycols) +
  #geom_boxplot(width = 0.1) +
  stat_summary(fun.data=mean_sdl, mult=1, 
                 geom="pointrange", color="black") +
  labs(title = "Scale") +
  theme_bw() -> p2

plot_grid(p1, p2)
```


**What happens when we do complete pooling of the data instead of analyzing the variation by individuals. If instead we take all seed dispersal data and randomly sample seeds, and fit a Weibull kernel?** This is the comparisson between pooling or no pooling of seed dispersal data. 

```{r}
weib.boot.pool <- NULL

for(j in 1:n.boots){
      s.df <- df %>% drop_na(s.id) %>%
      sample_n(., samp.size)

    
    g <- fitdistr(s.df$disp, densfun = "weibull", lower = c(0,0))
    
    prms.weib <- data.frame(est.shape = as.numeric(g$estimate[1]),
                              est.scale = as.numeric(g$estimate[2]),
                              loglik = g$loglik, indiv = 0)
    
    weib.boot.pool <- rbind.data.frame(weib.boot.pool, prms.weib %>% mutate(boot = j))
}

```

```{r}

weib.boot %>% 
  rbind.data.frame(., weib.boot.pool) -> weib.boot

weib.boot %>% 
  ggplot(., aes(x = factor(indiv), y = est.shape, color = factor(indiv))) +
  geom_violin() +
  scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.1) +
  # geom_point(color = "grey", alpha = 0.5) +
  stat_summary(fun.data=mean_sdl, mult=1, 
                 geom="pointrange", color="black") +
  labs(title = "Shape") +
  theme_bw() -> p1
# p1

weib.boot %>% 
  ggplot(., aes(x = factor(indiv), y = est.scale, color = factor(indiv))) +
  geom_violin() +
  scale_color_manual(values = c("black", mycols)) +
  #geom_boxplot(width = 0.1) +
  # geom_point() +
  stat_summary(fun.data=mean_sdl, mult=1, 
                 geom="pointrange", color="black") +
  labs(title = "Scale") +
  theme_bw() -> p2

plot_grid(p1, p2)
```

```{r}
weib.curves <- NULL

for(i in 1:5){
  weib.boot %>% 
  filter(indiv == i) -> a

  b <- purrr::map(seq(1:nrow(a)), function(y)
    stat_function(fun = dweibull, args = list(scale = a$est.scale[y], shape = a$est.shape[y]), color = mycols[i], alpha = 0.3))
  
  weib.curves <- append(weib.curves, b)
}

weib.boot %>% 
  filter(indiv == 0) -> c
weib.curves.pool <- purrr::map(seq(1:nrow(a)), function(y)
    stat_function(fun = dweibull, args = list(scale = c$est.scale[y], shape = c$est.shape[y]), color = "black", alpha = 0.8))


# ggplot(data = data.frame(x = c(1, 60)), aes(x)) +
#   weib.curves +
#   ylab("Density") + xlab("Distance (m)") +
#   theme_bw()  +
#   theme(legend.position = c(0.7, 0.7),
#         legend.title = element_blank()) 
df %>%
  drop_na(s.id) %>% 
  ggplot(., aes(x = disp)) +
  geom_histogram(aes(y = ..density..), fill = "grey") +
  theme_bw() -> p
# p
# 
# p +
#   stat_function(fun = dweibull, args = list(scale = weib.boot$est.scale[1], shape = weib.boot$est.shape[1]), color = "red")

p + 
  weib.curves +
  weib.curves.pool
  

```


This is only an example for the first population, but the overall idea is that if an individual has a larger movement rate, it moves more and this tends to translate into moving further away. As a consequence, the individuals with higher movement rates disperse seeds farther away and more scattered, in comparison to individuals with lower movement rates. Thus, the seed dispersal kernels produced by these individuals also show this trend, where individuals with higher movement rates disperse seeds further. This shows with the fatter tails of the kernels, evidenced by the larger scale parameters from fitted Weibull distributions. 
When we pool the seed dispersal data, we ignore individual differences in how each disperser moved the seeds, and estimate a single dispersal kernel sampling from all the seeds, regardless of who dispersed it. 

## Comparisson of seed dispersal kernels across populations  
These populations all have the same average movement rates, but their variance is different. Since we are sampling individuals from these lognormally distributed populations, that means that the populations have similar averages, but in the first population individuals are very similar to each other, whereas in the third population, the individuals have movement rates more spread out. By having individuals more spread out, it means that not only are we getting individuals with much higher movement rates, we are also getting them with much lower movement rates as well. Depending on the population, we could also ask whether or not all populations follow this lognormal distribution. This is more of a behavior question, do all animals move at the same rate? meaning all very close to the average. Do most animals move at the same rate, except for some very few that like to explore and go far away? Perhaps this population needs a more skewed distribution with a longer tail. Or perhaps this relates to breeding seasons instead, or droughts.

```{r}

# For second population
df2 <- NULL
summ.df2 <- NULL

for(j in 1:n.individuals){
  for(k in 1:nruns){
    a <- sim_seeds(m.prms = m_2[j]) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    b <- summ_seeds(a) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    df2 <- rbind.data.frame(df2, a) 
    summ.df2 <- rbind.data.frame(summ.df2, b) 
  }
}

# #If we wanted to visualize 
# summ.df2 %>% 
#   ggplot(., aes(y = dsprsn, x = indiv, color = indiv)) +
#   geom_boxplot() +
#   geom_point(color = "grey", alpha = 0.5) +
#   labs(title = "Dispersion") +
#   theme_bw() +
#   theme(legend.position = "none") -> p1
# # p1
# 
# summ.df2 %>% 
#   ggplot(., aes(y = av.disp, x = indiv, color = indiv)) +
#   geom_boxplot() +
#   geom_point(color = "grey", alpha = 0.5) +
#   labs(title = "Average dispersal per run") +
#   theme_bw() +
#   theme(legend.position = "none") -> p2
# # p2
# 
# plot_grid(p1, p2)

########################################################
# Bootstrap for individuals
weib.boot2 <- NULL

for(j in 1:n.boots){
  s.df <- df2 %>% drop_na(s.id) %>%
    group_by(indiv) %>%
    sample_n(., samp.size)
  
  # s.df <- df %>% drop_na(s.id)
  
  weib.fits <- NULL
  
  for(i in 1:n.individuals){
    dat <- s.df %>% 
      filter(indiv == i)
    #g <- fitdist(dat$disp, distr = "weibull", method = 'mle', lower = c(0,0))
    g <- fitdistr(dat$disp, densfun = "weibull", lower = c(0,0))
    prms.weib <- data.frame(est.shape = as.numeric(g$estimate[1]),
                            est.scale = as.numeric(g$estimate[2]),
                            loglik = g$loglik, indiv = i)
    weib.fits <- rbind.data.frame(weib.fits, prms.weib)
    # plot(g)
  }
  
  weib.boot2 <- rbind.data.frame(weib.boot2, weib.fits %>% mutate(boot = j))
}

# Pooled bootstrap
weib.boot.pool2 <- NULL

for(j in 1:n.boots){
  s.df <- df2 %>% drop_na(s.id) %>%
    sample_n(., samp.size)
  
  
  g <- fitdistr(s.df$disp, densfun = "weibull", lower = c(0,0))
  
  prms.weib <- data.frame(est.shape = as.numeric(g$estimate[1]),
                          est.scale = as.numeric(g$estimate[2]),
                          loglik = g$loglik, indiv = 0)
  
  weib.boot.pool2 <- rbind.data.frame(weib.boot.pool2, prms.weib %>% mutate(boot = j))
}
```

```{r}

# For Third population
df3 <- NULL
summ.df3 <- NULL

for(j in 1:n.individuals){
  for(k in 1:nruns){
    a <- sim_seeds(m.prms = m_3[j]) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    b <- summ_seeds(a) %>% 
      mutate(indiv = as.factor(j),
             run = factor(paste0("r_", k), levels = paste0("r_", 1:nruns)))
    
    df3 <- rbind.data.frame(df3, a) 
    summ.df3 <- rbind.data.frame(summ.df3, b) 
  }
}

# #If we wanted to visualize 
# summ.df3 %>% 
#   ggplot(., aes(y = dsprsn, x = indiv, color = indiv)) +
#   geom_boxplot() +
#   geom_point(color = "grey", alpha = 0.5) +
#   labs(title = "Dispersion") +
#   theme_bw() +
#   theme(legend.position = "none") -> p1
# # p1
# 
# summ.df3 %>% 
#   ggplot(., aes(y = av.disp, x = indiv, color = indiv)) +
#   geom_boxplot() +
#   geom_point(color = "grey", alpha = 0.5) +
#   labs(title = "Average dispersal per run") +
#   theme_bw() +
#   theme(legend.position = "none") -> p2
# # p2
# 
# plot_grid(p1, p2)

########################################################
# Bootstrap for individuals
weib.boot3 <- NULL

for(j in 1:n.boots){
  s.df <- df3 %>% drop_na(s.id) %>%
    group_by(indiv) %>%
    sample_n(., samp.size)
  
  # s.df <- df %>% drop_na(s.id)
  
  weib.fits <- NULL
  
  for(i in 1:n.individuals){
    dat <- s.df %>% 
      filter(indiv == i)
    #g <- fitdist(dat$disp, distr = "weibull", method = 'mle', lower = c(0,0))
    g <- fitdistr(dat$disp, densfun = "weibull", lower = c(0,0))
    prms.weib <- data.frame(est.shape = as.numeric(g$estimate[1]),
                            est.scale = as.numeric(g$estimate[2]),
                            loglik = g$loglik, indiv = i)
    weib.fits <- rbind.data.frame(weib.fits, prms.weib)
    # plot(g)
  }
  
  weib.boot3 <- rbind.data.frame(weib.boot3, weib.fits %>% mutate(boot = j))
}

# Pooled bootstrap
weib.boot.pool3 <- NULL

for(j in 1:n.boots){
  s.df <- df3 %>% drop_na(s.id) %>%
    sample_n(., samp.size)
  
  
  g <- fitdistr(s.df$disp, densfun = "weibull", lower = c(0,0))
  
  prms.weib <- data.frame(est.shape = as.numeric(g$estimate[1]),
                          est.scale = as.numeric(g$estimate[2]),
                          loglik = g$loglik, indiv = 0)
  
  weib.boot.pool3 <- rbind.data.frame(weib.boot.pool3, prms.weib %>% mutate(boot = j))
}
```

```{r}

weib.boot.pool %>% 
  mutate(popu = 1) %>% 
  bind_rows(., weib.boot.pool2 %>% 
              mutate(popu = 2)) %>% 
  bind_rows(., weib.boot.pool3 %>% 
              mutate(popu = 3)) -> weib.boot.pool

weib.boot.pool %>% 
  ggplot(., aes(x = factor(popu), y = est.shape, color = factor(popu))) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.1) +
  # geom_point(color = "grey", alpha = 0.5) +
  stat_summary(fun.data=mean_sdl, mult=1, 
                 geom="pointrange", color="black") +
  labs(title = "Shape") +
  theme_bw() -> p1
# p1

weib.boot.pool %>% 
  ggplot(., aes(x = factor(popu), y = est.scale, color = factor(popu))) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  #geom_boxplot(width = 0.1) +
  # geom_point() +
  stat_summary(fun.data=mean_sdl, mult=1, 
                 geom="pointrange", color="black") +
  labs(title = "Scale") +
  theme_bw() -> p2

plot_grid(p1, p2)
```
```{r}
summ.df %>% 
  mutate(popu = 1) %>% 
  bind_rows(summ.df2 %>% 
              mutate(popu = 2)) %>% 
  bind_rows(., summ.df3 %>% 
              mutate(popu = 3)) %>% 
  ggplot(., aes(y = dsprsn, x = factor(popu), color = factor(popu))) +
  geom_boxplot() +
  geom_point(color = "grey", alpha = 0.5) +
  labs(title = "Dispersion") +
  theme_bw() +
  theme(legend.position = "none") -> p1
# p1

summ.df %>% 
  mutate(popu = 1) %>% 
  bind_rows(summ.df2 %>% 
              mutate(popu = 2)) %>% 
  bind_rows(., summ.df3 %>% 
              mutate(popu = 3)) %>% 
  ggplot(., aes(y = av.disp, x = factor(popu), color = factor(popu))) +
  geom_boxplot() +
  geom_point(color = "grey", alpha = 0.5) +
  labs(title = "Average dispersal per run") +
  theme_bw() +
  theme(legend.position = "none") -> p2
# p2

plot_grid(p1, p2)
```

 
