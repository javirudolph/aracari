---
title: "Implications of animal movement rate variation in spatial patterns of seed dispersal"
author: "Javiera Rudolph"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
# knitr::opts_chunk$set(fig.width=12, fig.height=6)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(cowplot)
library(fitdistrplus)
library(Hmisc)
library(gtsummary)
library(extRemes)
```


```{r include=FALSE}
set.seed(98)

# Source functions -----------------------------------------------------------------

source("Ch1_movement_rates/Ch1_functions.R")

# LOAD the data ------------------------------------------------------------------------

load(file = "Ch1_movement_rates/ptpl.RData")

null_moverate <- data.frame(Bird_ID = unique(ptpl$Bird_ID), movrate = mean(ptpl$mpm))

indiv_moverate <- ptpl %>%
  group_by(Bird_ID, fam_g) %>%
  summarise(movrate = mean(mpm))

fam_moverate <- ptpl %>%
  group_by(fam_g) %>%
  summarise(movrate = mean(mpm),
            sd = sd(mpm))

ids <- ptpl %>% distinct(., Bird_ID, fam_g)

# Average movement rate for this 'population'
# mean(indiv_moverate$movrate)
# mean(ptpl$mpm)

# Color palette ----------------------------------------
my.cols1 <- c("#23262f","#717492","#b3a82a","#c94f21","#980012","#0d907a","#b9bec3")
scales::show_col(my.cols1)

# Fit a lognormal to the distribution of movement rates

logfit <- fitdist(indiv_moverate$movrate, distr = 'lnorm')
movrate_cp_ln <- as.numeric(exp(logfit$estimate[1]))

```

# Figure 1  

```{r}
# Figure 1 - example of how the process works.
# set.seed(72)
# set.seed(987)
set.seed(235)

cols.fig1 <- c("#23262f","#717492","#b3a82a","#c94f21","#980012","#0d907a","#b9bec3")
#library(scales)
#show_col(cols.fig1)

# We are using 5 seeds
nseeds <- 5

# Doing one run for the first three panels.

test_run <- sim_seeds(nseeds = nseeds, m.prms = movrate_cp_ln)
#test_run

# Calculate summary for seeds in this run
summ_test_run <- summ_seeds(test_run)
# Visualize this one run:
test_run %>%
  ggplot(., aes(x = xloc, y = yloc)) +
  geom_path(color = cols.fig1[2]) +
  geom_point(aes(x=0, y=0), color = cols.fig1[6], size = 4) +
  geom_point(data = test_run %>% drop_na(s.id),
             aes(x = xloc, y = yloc), shape = "diamond", size = 2.5) +
  # geom_point(data = summ_test_run,
  #            aes(x = x, y = y), color = "#59879A") +
  labs(x = "x", 
       #title = "Example of one simulation run",
       y = "y") +
  theme_bw() -> A

test_run %>%
  ggplot(., aes(x = xloc, y = yloc)) +
  geom_path(color = "white", alpha = 0.1) +
  geom_segment(data = test_run %>% drop_na(s.id),
               aes(x = xloc, y = yloc, xend = summ_test_run$x, yend = summ_test_run$y), lty = 2, color = cols.fig1[4]) +
  geom_point(data = test_run %>% drop_na(s.id),
             aes(x = xloc, y = yloc), shape = "diamond", size = 2.5) +
  geom_point(aes(x=0, y=0), color = cols.fig1[6], size = 4) +
  geom_point(data = summ_test_run,
             aes(x = x, y = y), color = cols.fig1[4], size = 4, shape = "square") +
  labs(x = "x", 
       #title = "Average dispersal and dispersion per run",
       y = "y") +
  theme_bw() -> B

test_run %>%
  ggplot(., aes(x = xloc, y = yloc)) +
  geom_path(color = "white", alpha = 0.1) +
  geom_segment(aes(x = summ_test_run$x, xend = 0, y = summ_test_run$y, yend = 0), color = cols.fig1[1], lty = "twodash") +
  geom_segment(data = test_run %>% drop_na(s.id),
               aes(x = xloc, y = yloc, xend = 0, yend = 0), lty = 2, color = cols.fig1[6]) +
  #geom_segment(aes(x = summ_test_run$x, xend = 0, y = summ_test_run$y, yend = 0), color = "#87A986", lty = 2) +
  geom_point(data = test_run %>% drop_na(s.id),
             aes(x = xloc, y = yloc), shape = "diamond", size = 2.5) +
  geom_point(data = summ_test_run,
             aes(x = x, y = y), color = cols.fig1[4], size = 4, shape = "square") +
  geom_point(aes(x=0, y=0), color = cols.fig1[6], size = 4) +
  labs(x = "x",
       #title = "Seed dispersal distance from parent tree",
       y = "y") +
  theme_bw() -> C

# The fourth panel will show the histogram and weibull fit for the seed dispersal kernel generated from 100 simulation runs
kruns <- 100
test.df <- NULL
test.summ.df <- NULL

for(k in 1:kruns){
  a <- sim_seeds(m.prms = movrate_cp_ln, nseeds = nseeds) %>%
    mutate(run = factor(paste0("r_", k), levels = paste0("r_", 1:kruns)),
           model = "test")

  b <- summ_seeds(a) %>%
    mutate(run = factor(paste0("r_", k), levels = paste0("r_", 1:kruns)),
           model = "test")

  test.df <- rbind.data.frame(test.df, a)
  test.summ.df <- rbind.data.frame(test.summ.df, b)
}

test.df %>% drop_na(s.id) -> seed.df

weib.fit <- fitdistr(seed.df$disp, densfun = "weibull")


test.df %>%
  drop_na(s.id) %>%
  ggplot(., aes(x = disp)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = cols.fig1[7], color = cols.fig1[6]) +
  stat_function(fun = dweibull, args = list(shape = weib.fit$estimate[1], scale = weib.fit$estimate[2]),
                color = "black", alpha = 0.8, size = 1) +
  labs(x = "Distance in meters", 
       #title = "SDK from 100 runs",
       y = "Density") +
  theme_bw() -> D


plot_grid(A, B, C, D, labels = "AUTO")

# ggsave2(filename = "Ch1_movement_rates/Figures/Figure1.png")
```


**Figure1** - Simulation process overview and seed dispersal measures.  Panels A through C represent one simulation run, whereas panel D shows the results from 100 simulation runs. A) An animal starts at the origin (coordinates (0,0) represented by the teal dot) where it ingests five seeds. The animal moves in the landscape (grey trajectory path) and drops seeds (black diamonds) as it reaches their gut retention time. B) The mean seed location per run is calculated and shown in the orange square. The distance of each seed to the mean location is used to calculate seed dispersion as described in the main text. C) Average seed dispersal per run (black dashed line) is calculated as the distance from the origin (teal dot) to the mean seed location (orange square). Seed dispersal distance for each seed (teal dashed lines) are calculated as the distance of each seed from the origin. D) Seed dispersal distances for each seed in 100 simulation runs are used to generate a seed dispersal distance histogram. A Weibull distribution is fit to the data to describe the seed dispersal kernel.

# Table 1  

```{r}
ptpl %>% 
  group_by(Bird_ID, fam_g) %>% 
  summarise(movrate = round(mean(mpm),1),
            obs = n()) %>% 
  left_join(., ptpl %>% 
              group_by(fam_g) %>% 
              summarise(famrate = round(mean(mpm), 1))) %>% 
  dplyr::select(Bird_ID, obs, movrate, fam_g, famrate) -> table1

knitr::kable(table1)
# write.csv(table1, file = "Ch1_movement_rates/Figures/table1.csv")

```


# Figure 2   

```{r}
# Visualize distribution and data points

load("Ch1_movement_rates/sims_backup/movrates.RData")

cols.fig2 <- c("#23262f","#717492","#b3a82a","#c94f21","#980012","#0d907a","#b9bec3")

# Movement rates used for each scenario

# movrate_cp
# movrate_np
# movrate_pp

movratedf <- data.frame(scenario = "cp", group = NA, movrate = movrate_cp) %>% 
  bind_rows(., data.frame(scenario = rep("pp", 42), group = movrate_pp$fam_g, movrate = movrate_pp$movrate)) %>% 
  bind_rows(., data.frame(scenario = rep("np", 30), group = NA, movrate = movrate_np))

# Logfit plot

indiv_moverate %>%
  ggplot(., aes(x = movrate, y = 0.002, color = fam_g)) +
  geom_point(size = 3, alpha = 0.8) +
  # geom_point(data = fam_moverate, aes(x = movrate, y = 0.004),size = 3, alpha = 0.8, color = my.cols1[4]) +
  stat_function(fun = dlnorm, args = list(meanlog = logfit$estimate[1], sdlog = logfit$estimate[2]),
                color = "black", alpha = 0.8, size = 1) +
  scale_color_manual(values = cols.fig2) +
  labs(x = "Movement Rate (meters/minute)",
       y = "Density",
       subtitle = "Lognormal fit to individual movement rates") +
  #geom_vline(xintercept = vlines, color = my.cols1[4], size = 1, lty = 2) +
  scale_x_continuous(limits = c(0, 70)) +
  #scale_x_discrete(labels = c(0, vlines[1], 20, vlines[2], 40, vlines[3], 60)) +
  guides(color = guide_legend(title = "Social Group",
                              ncol = 2)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  NULL -> logfit_plot

# Estimate the mu's for each family group based on their movement rate.
logfit.sigma <- logfit$estimate[2]
get_mu <- function(movrate, sigma = logfit.sigma){
  mu <- log(movrate)-((sigma^2)/2)
  return(mu)
}

fam_mus <- get_mu(fam_moverate$movrate)

glines <- purrr::map(1:7, function(y)
    stat_function(fun = dlnorm, args = list(meanlog = fam_mus[y], sdlog = logfit.sigma), color = cols.fig2[y]))


fam_moverate %>%
  ggplot(., aes(x = movrate, y = -0.002, color = fam_g)) +
  geom_point(size = 3, alpha = 0.8) +
  glines +
  scale_color_manual(values = cols.fig2) +
  labs(x = "Movement Rate (meters/minute)", 
       y = "Density",
       subtitle = "Distribution for social group movement rates") +
  #geom_vline(xintercept = vlines, color = my.cols1[4], size = 1, lty = 2) +
  scale_x_continuous(limits = c(0, 70)) +
  #scale_x_discrete(labels = c(0, vlines[1], 20, vlines[2], 40, vlines[3], 60)) +
  guides(color = guide_legend(title = "Social Group",
                              ncol = 2)) +
  theme_bw() +
  theme(legend.position = c(0.8, 0.6),
        axis.title.x = element_blank()) -> social_group_curves

movratedf %>% 
  ggplot(., aes(x = movrate, y = factor(scenario, levels = c("pp", "np", "cp")), color = as.character(group))) +
  geom_jitter(size = 3, alpha = 0.8, height = 0.1) +
  scale_color_manual(values = cols.fig2) +
  scale_x_continuous(limits = c(0, 70)) +
  labs(x = "Movement Rate (meters/minute)", y = "Scenario",
       subtitle = "Sampled movement rates for each simulated scenario") +
  #scale_x_discrete(labels = c(0, vlines[1], 20, vlines[2], 40, vlines[3], 60)) +
  guides(color = guide_legend(title = "Social Group",
                              ncol = 2)) +
  theme_bw() +
  theme(legend.position = "none") +
  NULL-> movrates_used

```

```{r fig.height=7, fig.width=5}
plot_grid(logfit_plot, social_group_curves, movrates_used, nrow = 3, rel_heights = c(2,2,1), labels = "AUTO")


# ggsave2(filename = "Ch1_movement_rates/Figures/Figure2.png")

```




# Figure 3 - gut retention times:  


```{r include=FALSE}
load("data/grt_data.rda") 


grt_fit <- fitdist(grt_data$grt, "gamma")
plot(grt_fit)

```

```{r}

grt_data %>% 
  ggplot() +
  geom_histogram(aes(x = grt, y = ..density..), fill = my.cols1[7], bins = 20) +
  stat_function(fun = dgamma, args = list(shape = grt_fit$estimate[1], rate = grt_fit$estimate[2])) +
  #stat_function(fun = dgamma, args = list(shape = 4, scale = 5), color = "red") + 
  geom_point(aes(x = grt, color = Bird_ID, y = 0), size = 4) +
  scale_color_manual(values = c(my.cols1[4], my.cols1[2], my.cols1[3], my.cols1[1])) +
  theme_bw() +
  labs(x = "Gut retention time in minutes", y = "Density") +
  theme(legend.position = "none")+
  NULL

# ggsave2(filename = "Ch1_movement_rates/Figures/Figure3.png")

```


 



```{r}
# Bring data --------------------------------------------
load("Ch1_movement_rates/sims_backup/datagen_cp.RData")
load("Ch1_movement_rates/sims_backup/datagen_pp.RData")
load("Ch1_movement_rates/sims_backup/datagen_np.RData")

load("Ch1_movement_rates/sims_backup/weib_cp.RData")
load("Ch1_movement_rates/sims_backup/weib_pp.RData")
load("Ch1_movement_rates/sims_backup/weib_np.RData")


```

```{r}
# Dispersion and Dispersal --------------------------------------------------------------------

cp.summ.df %>%
  dplyr::select(av.disp, dsprsn, model) %>% 
  bind_rows(., pp.summ.df %>%
              dplyr::select(av.disp, dsprsn, model)) %>%
  bind_rows(., np.summ.df %>%
              dplyr::select(av.disp, dsprsn,  model)) %>% 
  mutate(model = toupper(model),
         model = factor(model, levels = c("CP", "PP","NP"))) -> disp_df
```


# Figure 4 - average dispersal and dispersion per run  

Build a table with quantiles or summary stats for the dispersal and dispersion per run. Dispersion tells us how spread appart the seeds are from each other during a simulation. I would expect that for individuals with higher movement rates dispersion might be higher for their simulation runs too. This because a higher movement rate would extend the tail of the exponential distribution for movement distances, and thus have a larger range for movement distances, with a higher probability larger movement distances. So, during a simulation, a bird would see itself taking larger steps if they have a larger movement rate. Thus, their seeds would potentially be distributed more far apart. 


```{r}
  
disp_df %>% 
  group_by(model) %>% 
  summarise(av.disp = c(mean(av.disp), sd(av.disp), n(), round(quantile(av.disp, c(0, 0.25, 0.5, 0.75, 0.9, 1)), digits = 1)),
            dsprsn = c(mean(dsprsn), sd(dsprsn), n(), round(quantile(dsprsn, c(0, 0.25, 0.5, 0.75, 0.9, 1)),digits = 1)),
            q = c("mean", "sd", "n", "min", 0.25, 0.5, 0.75, 0.9, "max")) %>% 
  pivot_longer(cols = c(av.disp, dsprsn), names_to = "property", values_to = "value") %>% 
  pivot_wider(., names_from = q, values_from = value) %>% 
  arrange(., property) -> qtable_models

qtable_models
```


### Idea for dispersal and dispersion 


```{r fig.width=9, fig.height=3}

disp_df %>%
  group_by(., model) %>%
  ggplot(., aes(x = dsprsn, y = factor(model, levels = c("NP", "PP", "CP")))) +
  geom_violin(color = my.cols1[7], fill = my.cols1[7]) +
  geom_boxplot(width = 0.1, color = "black") +
  labs(x = "Dispersion per run (m)") +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.y = element_blank()) -> p_dispersion

disp_df %>%
  group_by(., model) %>%
  ggplot(., aes(x = av.disp, y = factor(model, levels = c("NP", "PP", "CP")))) +
  geom_violin(color = my.cols1[7], fill = my.cols1[7]) +
  geom_boxplot(width = 0.1, color = "black") +
  #geom_point(color = "grey", alpha = 0.5) +
  scale_color_manual(values = c(my.cols1[6], my.cols1[7])) +
  labs(x = "Average dispersal per run (m)") +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.y = element_blank()) -> p_dispersal

disp2_plot <- plot_grid(p_dispersal, p_dispersion, ncol = 2, labels = c("A)", "B)"), hjust = 0, vjust = 1, label_size = 10)

# disp2_plot
# ggsave2(filename = "Ch1_movement_rates/Figures/Figure4.png")



# Thinking about the long distance or spread: visualize or focus on the 90th percentile data?

```

```{r}
points_plot <- function(seed.data, s.size = 50000, xylims=1250, scenario = NULL, lalpha = 0.5){
  
  seed.data %>% 
    drop_na(s.id) %>% 
    mutate(LDD = ifelse(disp <500, NA, "Over 500m")) %>% 
    sample_n(s.size) %>% 
      ggplot(., aes(x = xloc, 
                    y = yloc
                    , color = LDD
                    )) +
      geom_hex()+
      scale_fill_gradient(low = "grey", high = "black") +
      #geom_point(alpha = lalpha) +
      scale_color_manual(values = my.cols1[6], na.translate = F) +
      geom_text(label = scenario, x = -1100, y = -1100, color = "black") +
      coord_equal(xlim = c(-xylims, xylims), ylim = c(-xylims, xylims)) +
      theme_bw() +
      theme(legend.position = "none",
            axis.title = element_blank()) +
       NULL
}
```

```{r fig.width=9, fig.height=3.5}
A <- points_plot(seed.data = cp.summ.df %>% 
              mutate(disp = av.disp,
                     s.id = run,
                     xloc = x,
                     yloc = y), scenario = "CP")
B <- points_plot(seed.data = pp.summ.df %>% 
              mutate(disp = av.disp,
                     s.id = id,
                     xloc = x,
                     yloc = y), scenario = "PP")
C <- points_plot(seed.data = np.summ.df %>% 
              mutate(disp = av.disp,
                     s.id = id,
                     xloc = x,
                     yloc = y), scenario = "NP")
prowB <- plot_grid(A, B, C, ncol = 3)
legend <- get_legend(C + theme(legend.position = "bottom") +
  scale_fill_gradient(low = "lightgray", high = "black",
                                             name = "Count",
                          guide = guide_colorbar(barwidth = 15, 
                                                barheight = 0.5,
                                                title.position = "left",
                                                title.vjust = 1.1,
                                                 #label.position = "left",
                                                 nbin = 100)) +
    guides(color = guide_legend(title = element_blank(),override.aes = list(fill = "lightgray",
                                                                            size = 5), direction = "horizontal")))
hexplot <- plot_grid(prowB, legend, rel_heights = c(1,0.1), ncol = 1, labels = c("C)"), hjust = 0, vjust = 1, label_size = 10)

```


```{r fig.height=7.5, fig.width=9}
plot_grid(disp2_plot, NULL, hexplot, nrow = 3, rel_heights = c(1,0.05,1))

#ggsave2(filename = "Ch1_movement_rates/Figures/Figure4.png")

```


Figure 5 - Dispersal kernels

```{r fig.width=9, fig.height=3.5, eval = FALSE}

A <- points_plot(seed.data = cp.df, scenario = "CP")
B <- points_plot(seed.data = pp.df, scenario = "PP")
C <- points_plot(seed.data = np.df, scenario = "NP") 

prow <- plot_grid(A, B, C, ncol = 3, labels = "A")


legend <- get_legend(C + theme(legend.position = "bottom") +
  scale_fill_gradient(low = "lightgray", high = "black",
                                             name = "Count",
                          guide = guide_colorbar(barwidth = 15, 
                                                barheight = 0.5,
                                                title.position = "left",
                                                title.vjust = 1.1,
                                                 #label.position = "left",
                                                 nbin = 100)) +
    guides(color = guide_legend(title = element_blank(),override.aes = list(fill = "lightgray",
                                                                            size = 5), direction = "horizontal")))




seedplots2d <- plot_grid(prow, legend, rel_heights = c(1,0.1), ncol = 1)
seedplots2d


```

```{r loadingData}

# Weibull fit ------------------------------------------------------------

weib.boot.cp %>%
  dplyr::select(., est.shape, est.scale, boot, model) %>%
  bind_rows(., weib.boot.pp %>%
              dplyr::select(., est.shape, est.scale, boot, model)) %>%
  bind_rows(., weib.boot.np %>%
              dplyr::select(., est.shape, est.scale, boot, model)) -> joint_weib

joint_weib %>% 
  mutate(model = toupper(model),
         model = factor(model, levels = c("CP", "PP","NP"))) -> joint_weib

### Calculate the mean and variance for these weibull distributions based on their estimated parameters

meanvar.weibull <- function(shape, scale){
  
  meanweibull <- scale * gamma(1+(1/shape))
  
  varweibull <- (scale^2)*(gamma(1+(2/shape))-(gamma(1+(1/shape))^2))
  
  return(c(meanweibull, varweibull))
}


joint_weib %>% 
  mutate(meanweib = est.scale * gamma(1+(1/est.shape)),
         varweib = (est.scale^2)*(gamma(1+(2/est.shape))-(gamma(1+(1/est.shape))^2))) -> joint_weib

z.joint_weib <- joint_weib %>% 
  mutate(est.shape = scale(est.shape),
         est.scale = scale(est.scale),
         meanweib = scale(meanweib),
         varweib = scale(varweib))

```


```{r}

fig.5col <- c("#68655a", "#ff814f", "#31aec5")

z.joint_weib %>% 
  pivot_longer(., cols = c(est.shape, est.scale, meanweib, varweib)) %>% 
  ggplot(., aes(x = name, y = value, color = model)) +
  geom_boxplot() +
  labs(x = "Parameter", y = "Z score") +
  scale_x_discrete(labels = c("est.scale" = "Scale", "est.shape"="Shape", "meanweib" = "Mean", "varweib"="Variance")) +
  scale_color_manual(values = fig.5col) +
  theme_bw() +
  guides(color = guide_legend(title = "Model")) -> zscoreplot


#plot_grid(meanweib, varweib, nrow = 2, labels = c("A)", "B)"), hjust = 0, vjust = 1, label_size = 10)

```

```{r eval = FALSE}
joint_weib %>%
  group_by(model) %>%
  #sample_n(., 100) %>%
  ggplot(., aes(x = model, y = est.shape)) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.01) +
  # geom_point(color = "grey", alpha = 0.5) +
  # stat_summary(fun.data=mean_sdl, mult=1,
  #              geom="pointrange", color="black") +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  geom_hline(aes(yintercept = 1), lty = "dashed") +
  labs(y = "Shape") +
  #scale_y_continuous(limits = c(0, 2)) +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL -> weib_shape

joint_weib %>%
  group_by(model) %>%
  #sample_n(., 200) %>%
  ggplot(., aes(x = model, y = est.scale)) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.01) +
  # geom_point(color = "grey", alpha = 0.5) +
  # stat_summary(fun.data=mean_sdl, mult=1,
  #              geom="pointrange", color="black") +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  labs(y = "Scale") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL-> weib_scale


joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = meanweib)) +
  geom_violin() +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  #geom_hline(aes(yintercept = 1), lty = "dashed") +
  labs(y = "Mean") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL -> weib_mean

joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = varweib)) +
  geom_violin() +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  labs(y = "Variance") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL-> weib_variance

plot_grid(weib_shape, weib_scale, weib_mean, weib_variance, ncol = 4)

#ggsave2(filename = "Ch1_movement_rates/Figures/Figure5.png")

```


```{r Kde1dEstimates, include = FALSE}
library(kde1d)
  

# Kernel density estimation:

cp.shape.kde <- kde1d(weib.boot.cp$est.shape)
pp.shape.kde <- kde1d(weib.boot.pp$est.shape)
np.shape.kde <- kde1d(weib.boot.np$est.shape)

cp.scale.kde <- kde1d(weib.boot.cp$est.scale)
pp.scale.kde <- kde1d(weib.boot.pp$est.scale)
np.scale.kde <- kde1d(weib.boot.np$est.scale)


CIs.cp.shape <- qkde1d(p=c(0.025,0.5, 0.975), cp.shape.kde)
CIs.pp.shape <- qkde1d(p=c(0.025,0.5, 0.975), pp.shape.kde)
CIs.np.shape <- qkde1d(p=c(0.025,0.5, 0.975), np.shape.kde)

CIs.cp.scale <- qkde1d(p=c(0.025,0.5, 0.975), cp.scale.kde)
CIs.pp.scale <- qkde1d(p=c(0.025,0.5, 0.975), pp.scale.kde)
CIs.np.scale <- qkde1d(p=c(0.025,0.5, 0.975), np.scale.kde)

rbind(CIs.cp.shape, CIs.pp.shape, CIs.np.shape, CIs.cp.scale, CIs.pp.scale, CIs.np.scale) %>% 
  as.data.frame() %>% 
  rename(low = V1, median = V2, high = V3) %>%
  tibble::rownames_to_column("model") %>% 
  mutate(param = stringr::str_sub(model, start = 8),
         model =stringr::str_sub(model, start = 5, end = 6),
         model = toupper(model),
         model = factor(model, levels = c("CP", "PP", "NP"))) -> CIdata

joint_weib %>% 
  group_by(., model) %>% 
  summarise(meanshape = mean(est.shape),
            meanscale = mean(est.scale)) %>% 
  pivot_longer(cols = starts_with("mean")) %>% 
  mutate(param = stringr::str_sub(name, start = 5),
         mean = value) %>% 
  dplyr::select(., -c(value, name)) %>% 
  left_join(., CIdata) -> CIdata

CIdata %>% 
  pivot_longer(., cols = c(median, mean, low, high)) %>% 
  filter(., param == "shape" & name != "median") %>% 
  pivot_wider(names_from = name) -> CIshape

CIdata %>% 
  pivot_longer(., cols = c(median, mean, low, high)) %>% 
  filter(., param == "scale" & name != "median") %>% 
  pivot_wider(names_from = name) -> CIscale

```

```{r RunPurrrCurves}

xmax <- 1500
ncurves <- 200

cp_lines <- purrr::map(seq(1:ncurves), function(y)
  stat_function(fun = dweibull, args = list(scale = weib.boot.cp$est.scale[y], shape = weib.boot.cp$est.shape[y]), color = fig.5col[1]))

pp_lines <- purrr::map(seq(1:ncurves), function(y)
  stat_function(fun = dweibull, args = list(scale = weib.boot.pp$est.scale[y], shape = weib.boot.pp$est.shape[y]), color = fig.5col[2]))

np_lines <- purrr::map(seq(1:ncurves), function(y)
  stat_function(fun = dweibull, args = list(scale = weib.boot.np$est.scale[y], shape = weib.boot.np$est.shape[y]), color = fig.5col[3]))

```

```{r KernelCurves}

coords <- c(600, 0.006)

ggplot() +
  cp_lines +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[1], scale = CIscale$mean[1]), color = "black", size = 1) +
  lims(x = c(0, xmax), y = c(0, 0.006)) +
  theme_bw() +
  labs(y = "Density", x = "Dispersal (m)") +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        panel.grid.major = element_blank()) +
  coord_cartesian(xlim = c(0, coords[1]), ylim = c(0, coords[2])) +
  NULL -> cp.dens

ggplot() +
  pp_lines +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[2], scale = CIscale$mean[2]), color = "black", size = 1) +
  lims(x = c(0, xmax), y = c(0, 0.006)) +
  theme_bw() +
  labs(y = "Density", x = "Dispersal (m)") +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        panel.grid.major = element_blank()) +
  coord_cartesian(xlim = c(0, coords[1]), ylim = c(0, coords[2])) +
  NULL -> pp.dens

ggplot() +
  np_lines +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[3], scale = CIscale$mean[3]), color = "black", size = 1) +
  lims(x = c(0, xmax), y = c(0, 0.006)) +
  theme_bw() +
  labs(y = "Density", x = "Dispersal (m)") +
  coord_cartesian(xlim = c(0, coords[1]), ylim = c(0, coords[2])) +
  theme(panel.grid.major = element_blank()) +
  NULL -> np.dens

kernelcurvesfig <- plot_grid(cp.dens, pp.dens, np.dens, nrow = 3)
#kernelcurvesfig

```

```{r eval = FALSE}
cp.dens +
  coord_cartesian(xlim = c(400, 800), ylim = c(0, 0.001)) -> cp.tail

pp.dens +
  coord_cartesian(xlim = c(400, 800), ylim = c(0, 0.001)) -> pp.tail

np.dens +
  coord_cartesian(xlim = c(400, 800), ylim = c(0, 0.001)) -> np.tail

plot_grid(cp.tail, pp.tail, np.tail, nrow = 3)

```

```{r KernelTails}

backgroundcol <- "#f7f2e4"
  #"#f7edd5"



cp.dens +
  coord_cartesian(xlim = c(600, 1000), ylim = c(0, 0.0001)) +
  theme(panel.background = element_rect(fill = backgroundcol),
        panel.grid = element_line(color = "white")) +
  labs(y = "") -> cp.tail

pp.dens +
  coord_cartesian(xlim = c(600, 1000), ylim = c(0, 0.0001)) +
  theme(panel.background = element_rect(fill = backgroundcol),
        panel.grid = element_line(color = "white")) +
  labs(y = "") -> pp.tail

np.dens +
  coord_cartesian(xlim = c(600, 1000), ylim = c(0, 0.0001)) +
  theme(panel.background = element_rect(fill = backgroundcol),
        panel.grid = element_line(color = "white")) +
  labs(y = "") -> np.tail

kernel_tails_fig <- plot_grid(cp.tail, pp.tail, np.tail, nrow = 3)
#kernel_tails_fig
```

```{r eval = FALSE}
# all density means

ggplot() +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[1], scale = CIscale$mean[1]), color = fig.5col[1], size = 1) +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[2], scale = CIscale$mean[2]), color = fig.5col[2], size = 1) +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[3], scale = CIscale$mean[3]), color = fig.5col[3], size = 1) +
  # Everything after this line is the confidence intervals
  #   stat_function(fun = dweibull, args = list(shape = CIshape$low[1], scale = CIscale$low[1]), color = fig.5col[1], size = 1, linetype = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = CIshape$low[2], scale = CIscale$low[2]), color = fig.5col[2], size = 1, linetype = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = CIshape$low[3], scale = CIscale$low[3]), color = fig.5col[3], size = 1, linetype = "dashed") +
  # lims(x = c(0, 1500), y = c(0, 0.006)) +
  #     stat_function(fun = dweibull, args = list(shape = CIshape$high[1], scale = CIscale$high[1]), color = fig.5col[1], size = 1, linetype = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = CIshape$high[2], scale = CIscale$high[2]), color = fig.5col[2], size = 1, linetype = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = CIshape$high[3], scale = CIscale$high[3]), color = fig.5col[3], size = 1, linetype = "dashed") +
  lims(x = c(0, 1500), y = c(0, 0.0062)) +
  theme_bw() +
  labs(y = "Density", x = "Dispersal (m)") +
#coord_cartesian(xlim = c(500, 1500), ylim = c(0, 0.0002)) +
    NULL


ggplot() +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[1], scale = CIscale$mean[1]), color = fig.5col[1], size = 1) +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[2], scale = CIscale$mean[2]), color = fig.5col[2], size = 1) +
  stat_function(fun = dweibull, args = list(shape = CIshape$mean[3], scale = CIscale$mean[3]), color = fig.5col[3], size = 1) +
  lims(x = c(0, 1500), y = c(0, 0.006)) +
  theme_bw() +
  labs(y = "Density", x = "Dispersal (m)") +
  coord_cartesian(xlim = c(500, 1500), ylim = c(0, 0.0003))
```

```{r ParamCIs}
CIdata %>% 
  filter(., param == "shape") %>% 
  ggplot(., aes(x  = model, y = mean, color = model)) +
  geom_point() +
  geom_segment(aes(y = low, yend = high, x = model, xend = model)) +
  labs(y = "Shape value", x = "Model") +
  scale_color_manual(values = fig.5col) +
  theme_bw() +
  theme(legend.position = "none") -> ShapeCI

CIdata %>% 
  filter(., param == "scale") %>% 
  ggplot(., aes(x  = model, y = mean, color = model)) +
  geom_point() +
  geom_segment(aes(y = low, yend = high, x = model, xend = model)) +
  labs(y = "Scale value", x = "Model") +
  scale_color_manual(values = fig.5col) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x = element_blank()) -> ScaleCI

CIparams_figure <- plot_grid(ScaleCI, ShapeCI, nrow = 2)
#CIparams_figure
# # The proportion of shape parameter values above the sampling distribution is 
# prop.above1.10.cp.shape <- 1-pkde1d(q=1.10, cp.shape.kde)
# prop.above1.10.pp.shape <- 1-pkde1d(q=1.10, pp.shape.kde)
# prop.above1.10.np.shape <- 1-pkde1d(q=1.10, np.shape.kde)
```

```{r MeanVar}

violincolor <- "lightgray"

joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = meanweib)) +
  geom_violin(color = violincolor, fill = violincolor) +
  geom_boxplot(width = 0.1, aes(color = model)) +
  scale_color_manual(values = fig.5col) +
  # geom_violin() +
  # geom_jitter(data = joint_weib %>% 
  #               group_by(model) %>% 
  #               sample_n(200),
  #             position = position_jitter(0.1)) +
  #geom_hline(aes(yintercept = 1), lty = "dashed") +
  labs(y = "Est. Mean", x = "Model") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        legend.position = "none") +
  NULL -> weib_mean

joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = varweib)) +
    geom_violin(color = violincolor, fill = violincolor) +
  geom_boxplot(width = 0.1, aes(color = model)) +
  scale_color_manual(values = fig.5col) +
  # geom_violin() +
  # geom_jitter(data = joint_weib %>% 
  #               group_by(model) %>% 
  #               sample_n(200),
  #             position = position_jitter(0.1)) +
  labs(y = "Est. Variance", x = "Model") +
  theme_bw() +
  theme(legend.position = "none") +
  NULL-> weib_variance

MeanVar_figure <- plot_grid(weib_mean, weib_variance, nrow = 2, align = "v")
#MeanVar_figure
```


```{r Figure5, fig.width=12, fig.height=7}

plot_grid(kernelcurvesfig, kernel_tails_fig, CIparams_figure, MeanVar_figure, ncol = 4, rel_widths = c(0.9, 1, 0.3, 0.6),
          labels = c("A)", "B)", "C)", "D)"), hjust = -0.5, vjust = 1, label_size = 10)

#ggsave2(filename = "Ch1_movement_rates/Figures/Figure5.png")

```


```{r fig.width=10, eval = FALSE}
data.frame(grid_points = cp.shape.kde$grid_points, values = cp.shape.kde$values, model = "CP", param = "shape") %>% 
  bind_rows(., data.frame(grid_points = pp.shape.kde$grid_points, values = pp.shape.kde$values, model = "PP", param = "shape")) %>% 
  bind_rows(., data.frame(grid_points = np.shape.kde$grid_points, values = np.shape.kde$values, model = "NP", param = "shape")) %>% 
  bind_rows(., data.frame(grid_points = cp.scale.kde$grid_points, values = cp.scale.kde$values, model = "CP", param = "scale") %>% 
  bind_rows(., data.frame(grid_points = pp.scale.kde$grid_points, values = pp.scale.kde$values, model = "PP", param = "scale")) %>% 
  bind_rows(., data.frame(grid_points = np.scale.kde$grid_points, values = np.scale.kde$values, model = "NP", param = "scale"))) %>% 
  mutate(model = factor(model, levels = c("CP", "PP", "NP"))) -> kerneldata


kerneldata %>% 
  filter(., param == "shape") %>% 
  ggplot(., aes(x = grid_points, y = values, color = model)) +
  geom_line() +
  labs(y = "Density", x = "Shape") +
  scale_color_manual(values = my.cols1[c(1,4,6)]) +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = c(0.9, 0.2)) -> shapeplot

kerneldata %>% 
  filter(., param == "scale") %>% 
  ggplot(., aes(x = grid_points, y = values, color = model)) +
  geom_line() +
  labs(y = "Density", x = "Scale") +
  scale_color_manual(values = my.cols1[c(1,4,6)]) +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = c(0.9, 0.2)) -> scaleplot

plot_grid(shapeplot, scaleplot, ncol = 2)

# plot(cp.shape.kde$grid_points, cp.shape.kde$values, type="l", lwd=2, bty="l", col="red", ylim = c(0,4))
# lines(pp.shape.kde$grid_points, pp.shape.kde$values, col="blue")
# lines(np.shape.kde$grid_points, np.shape.kde$values, col="black")
# 
# plot(cp.scale.kde$grid_points, cp.scale.kde$values, type="l", lwd=2, bty="l", col="red", ylim = c(0,0.04))
# lines(pp.scale.kde$grid_points, pp.scale.kde$values, col="blue")
# lines(np.scale.kde$grid_points, np.scale.kde$values, col="black")


```


```{r CIkernels, eval = FALSE}
cp_lines <- purrr::map(seq(1:100), function(y)
  stat_function(fun = dweibull, args = list(scale = weib.boot.cp$est.scale[y], shape = weib.boot.cp$est.shape[y]), color = fig.5col[1]))

pp_lines <- purrr::map(seq(1:100), function(y)
  stat_function(fun = dweibull, args = list(scale = weib.boot.pp$est.scale[y], shape = weib.boot.pp$est.shape[y]), color = fig.5col[2]))

np_lines <- purrr::map(seq(1:100), function(y)
  stat_function(fun = dweibull, args = list(scale = weib.boot.np$est.scale[y], shape = weib.boot.np$est.shape[y]), color = fig.5col[3]))


ggplot() +
  cp_lines +
  stat_function(fun = dweibull, args = list(shape = CIs.cp.shape[1], scale = CIs.cp.scale[1]), 
                color = "black", linetype = "dashed") +
  stat_function(fun = dweibull, args = list(shape = CIs.cp.shape[2], scale = CIs.cp.scale[2]), color = "black") +
  stat_function(fun = dweibull, args = list(shape = CIs.cp.shape[3], scale = CIs.cp.scale[3]),
                color = "black", linetype = "dashed") +
  lims(x = c(0, 1250)) +
  theme_bw() -> CPweibdens

ggplot() +
  pp_lines +
  stat_function(fun = dweibull, args = list(shape = CIs.pp.shape[1], scale = CIs.pp.scale[1]), 
                color = "black", linetype = "dashed") +
  stat_function(fun = dweibull, args = list(shape = CIs.pp.shape[2], scale = CIs.pp.scale[2]), color = "black") +
  stat_function(fun = dweibull, args = list(shape = CIs.pp.shape[3], scale = CIs.pp.scale[3]),
                color = "black", linetype = "dashed") +
  lims(x = c(0, 1250)) +
  theme_bw() -> PPweibdens

ggplot() +
  np_lines +
  stat_function(fun = dweibull, args = list(shape = CIs.np.shape[1], scale = CIs.np.scale[1]), 
                color = "black", linetype = "dashed") +
  stat_function(fun = dweibull, args = list(shape = CIs.np.shape[2], scale = CIs.np.scale[2]), color = "black") +
  stat_function(fun = dweibull, args = list(shape = CIs.np.shape[3], scale = CIs.np.scale[3]),
                color = "black", linetype = "dashed") +
  lims(x = c(0, 1250)) +
  theme_bw() -> NPweibdens


plot_grid(CPweibdens, PPweibdens, NPweibdens, nrow = 3)



```


```{r eval=FALSE}

smean.cl.normal(weib.boot.cp$est.shape) -> cp.shape
smean.cl.normal(weib.boot.cp$est.scale) -> cp.scale

smean.cl.normal(weib.boot.pp$est.shape) -> pp.shape
smean.cl.normal(weib.boot.pp$est.scale) -> pp.scale

smean.cl.normal(weib.boot.np$est.shape) -> np.shape
smean.cl.normal(weib.boot.np$est.scale) -> np.scale


cp.df %>% 
  bind_rows(pp.df, np.df) %>% 
  drop_na(., s.id) %>% 
  group_by(model) %>% 
  sample_n(5000) %>% 
  ggplot(., aes(x = disp)) +
  geom_histogram(aes(y = ..density..), fill = "lightgray") +
  stat_function(fun = dweibull, args = list(shape = cp.shape[1], scale = cp.scale[1]), color = "blue") +
  # stat_function(fun = dweibull, args = list(shape = cp.shape[2], scale = cp.scale[2]), color = "blue", lty = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = cp.shape[3], scale = cp.scale[3]), color = "blue", lty = "dashed") +
  stat_function(fun = dweibull, args = list(shape = pp.shape[1], scale = pp.scale[1]), color = "black") +
  # stat_function(fun = dweibull, args = list(shape = pp.shape[2], scale = pp.scale[2]), color = "black", lty = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = pp.shape[3], scale = pp.scale[3]), color = "black", lty = "dashed") +
  stat_function(fun = dweibull, args = list(shape = np.shape[1], scale = np.scale[1]), color = "red") +
  # stat_function(fun = dweibull, args = list(shape = np.shape[2], scale = np.scale[2]), color = "red", lty = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = np.shape[3], scale = np.scale[3]), color = "red", lty = "dashed") +
  theme_bw() +
  # geom_vline(aes(xintercept = 500)) +
  # coord_cartesian(xlim = c(500, 1700), ylim = c(0, 0.0005)) +
  NULL

```


# Table 2 - results  
Data for each seed, not per run

```{r}
# here::here()
disp_table <- read.csv("Ch1_movement_rates/Figures/table2.csv")

disp_table %>% 
  dplyr::select(., Model, Mean.dispersal_sd, kurtosis, Max_dispersal, LDD_500) -> disp_table

knitr::kable(disp_table)

```


### FIGURE 6 EVD generalized pareto results

1. Make threshold plot to figure out threshold
2. Make associated mean excess plot
3. Calculate the 95% quantile for mean excess to use as threshold
4. Make threshplot and show the threshold based on the mean excess
5. fit a gpd distribution using that threshold and report parameter values
6. Calculate conditional probabilities over certain distances

```{r include = FALSE}

# subset data ---------------------------------

nsamps <- 10000


cp.df %>%
  drop_na(., s.id) %>%
  sample_n(., nsamps) -> cp.evd

pp.df %>%
  drop_na(., s.id) %>%
  sample_n(., nsamps) -> pp.evd

np.df %>%
  drop_na(., s.id) %>%
  sample_n(., nsamps) -> np.evd


cp.evd %>%
  mutate(model = toupper(model)) %>%
  bind_rows(pp.evd %>% mutate(model = toupper(model))) %>%
  bind_rows(np.evd %>% mutate(model = toupper(model))) %>%
  group_by(model) %>%
  summarise(q75 = quantile(disp, 0.75),
            q90 = quantile(disp, 0.9),
            q99 = quantile(disp, 0.99),
            max = max(disp))

# Find threshold -------------------------------------
## CP ----------------------------

r <- c(0, 600)

nint <- 100
# r <- quantile(cp.evd$disp, c(0.75, 0.99))
u.i <- matrix(seq(r[1],r[2],,nint), ncol=1)

cp.mrl <- mrlplot(cp.evd$disp)
lm.cp <- lm(cp.mrl[,2]~1)
tval.cp <- confint(lm.cp, level = 0.9)[2]

thresh.cp <- threshrange.plot(cp.evd$disp, r = r, type = "GP", nint = nint) %>%
  as.data.frame() %>%
  mutate(u.i = u.i)


## PP ----------------------------

nint <- 100
# r <- quantile(pp.evd$disp, c(0.75, 0.99))
u.i <- matrix(seq(r[1],r[2],,nint), ncol=1)

pp.mrl <- mrlplot(pp.evd$disp)
lm.pp <- lm(pp.mrl[,2]~1)
tval.pp <- confint(lm.pp, level = 0.9)[2]

thresh.pp <- threshrange.plot(pp.evd$disp, r = r, type = "GP", nint = nint) %>%
  as.data.frame() %>%
  mutate(u.i = u.i)



## NP ----------------------------

nint <- 100
# r <- quantile(pp.evd$disp, c(0.75, 0.99))
u.i <- matrix(seq(r[1],r[2],,nint), ncol=1)

np.mrl <- mrlplot(np.evd$disp)
lm.np <- lm(np.mrl[,2]~1)
tval.np <- confint(lm.np, level = 0.9)[2]

thresh.np <- threshrange.plot(np.evd$disp, r = r, type = "GP", nint = nint) %>%
  as.data.frame() %>%
  mutate(u.i = u.i)


```


```{r fig.width=12, fig.height=4}
# Threshold figures

threshplot_fx <- function(thresh_data, th, r, model){
  
  th <- round(th)

  thresh_data %>%
    ggplot(., aes(y = t.scale, x = u.i)) +
    geom_point(shape = 1, size = 2) +
    # geom_line(linetype = "dashed") +
    geom_linerange(aes(x = u.i, ymin = low.t.scale, ymax = up.t.scale)) +
    labs(title = paste(model, "threshold =", th, "m"), 
         x = "Threshold in meters", y = "Scale") +
    theme_bw() +
    geom_vline(xintercept = th, color = "red", linetype = "dashed") +
    scale_x_continuous(limits = r, n.breaks = 7 ) +
    # scale_x_continuous(name = NULL, labels = NULL, breaks = NULL) +
    theme(axis.title.x = element_blank(),
          #axis.ticks.x = element_blank(),
          axis.text.x = element_blank()) +
    # coord_cartesian(xlim = c(200, 550)) +
    NULL -> thresh_scale

  thresh_data %>%
    ggplot(., aes(y = shape, x = u.i)) +
    geom_point(shape = 1, size = 2) +
    geom_linerange(aes(x = u.i, ymin = low.shape, ymax = up.shape)) +
    labs(x = "Threshold in meters", y = "Shape") +
    theme_bw() +
    geom_vline(xintercept = th, color = "red", linetype = "dashed") +
    scale_x_continuous(limits = r, n.breaks = 7 ) +
    # coord_cartesian(xlim = c(200, 550)) +
    NULL -> thresh_shape

  plot_grid(thresh_scale, thresh_shape, nrow = 2, align = "v")

}

plot.cp <- threshplot_fx(thresh_data = thresh.cp, th = tval.cp, r = r, model = "CP")
plot.pp <- threshplot_fx(thresh_data = thresh.pp, th = tval.pp, r = r, model = "PP")
plot.np <- threshplot_fx(thresh_data = thresh.np, th = tval.np, r = r, model = "NP")


plot_grid(plot.cp, plot.pp, plot.np, ncol = 3, labels = c("A)", "B)", "C)"), hjust = 0, vjust = 1, label_size = 10)
#ggsave2(filename = "Ch1_movement_rates/Figures/Figure6.png")

```


## Fit values

```{r}

evd.fit.cp <- fevd(cp.evd$disp, threshold = tval.cp, type = "GP")
evd.fit.pp <- fevd(pp.evd$disp, threshold = tval.pp, type = "GP")
evd.fit.np <- fevd(np.evd$disp, threshold = tval.np, type = "GP")

cbind(c("CP", "PP", "NP"), rbind(evd.fit.cp$results$par,
      evd.fit.pp$results$par,
      evd.fit.np$results$par))

```

Find the conditional probabilities. Probability of exceeding a distance x, based on the fitted distribution

```{r}

# To find the probability of exceeding 1000, 5000, or 10,000 meters based on the fitted ged 
dist_range <- c(200, 500, 1000, 5000)

cbind(c("Distance", "CP", "PP", "NP"), rbind(dist_range,
                                             pextRemes(evd.fit.cp, dist_range, lower.tail = FALSE),
                                             pextRemes(evd.fit.pp, dist_range, lower.tail = FALSE),
                                             pextRemes(evd.fit.np, dist_range, lower.tail = FALSE)))

```


Summary for the fits

```{r}
summary(evd.fit.cp)
plot(evd.fit.cp)
summary(evd.fit.pp)
plot(evd.fit.pp)
summary(evd.fit.np)
plot(evd.fit.np)


```





