---
title: "Implications of animal movement rate variation in spatial patterns of seed dispersal"
author: "Javiera Rudolph"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
# knitr::opts_chunk$set(fig.width=12, fig.height=6)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(cowplot)
library(fitdistrplus)
library(Hmisc)
library(gtsummary)
library(extRemes)
```


```{r include=FALSE}
set.seed(98)

# Source functions -----------------------------------------------------------------

source("Ch1_movement_rates/Ch1_functions.R")

# LOAD the data ------------------------------------------------------------------------

load(file = "Ch1_movement_rates/ptpl.RData")

null_moverate <- data.frame(Bird_ID = unique(ptpl$Bird_ID), movrate = mean(ptpl$mpm))

indiv_moverate <- ptpl %>%
  group_by(Bird_ID, fam_g) %>%
  summarise(movrate = mean(mpm))

fam_moverate <- ptpl %>%
  group_by(fam_g) %>%
  summarise(movrate = mean(mpm),
            sd = sd(mpm))

ids <- ptpl %>% distinct(., Bird_ID, fam_g)

# Average movement rate for this 'population'
# mean(indiv_moverate$movrate)
# mean(ptpl$mpm)

# Color palette ----------------------------------------
my.cols1 <- c("#23262f","#717492","#b3a82a","#c94f21","#980012","#0d907a","#b9bec3")
scales::show_col(my.cols1)

# Fit a lognormal to the distribution of movement rates

logfit <- fitdist(indiv_moverate$movrate, distr = 'lnorm')
movrate_cp_ln <- as.numeric(exp(logfit$estimate[1]))

```

# Figure 1  

```{r}
# Figure 1 - example of how the process works.
# set.seed(72)
# set.seed(987)
set.seed(235)

cols.fig1 <- c("#23262f","#717492","#b3a82a","#c94f21","#980012","#0d907a","#b9bec3")
#library(scales)
#show_col(cols.fig1)

# We are using 5 seeds
nseeds <- 5

# Doing one run for the first three panels.

test_run <- sim_seeds(nseeds = nseeds, m.prms = movrate_cp_ln)
#test_run

# Calculate summary for seeds in this run
summ_test_run <- summ_seeds(test_run)
# Visualize this one run:
test_run %>%
  ggplot(., aes(x = xloc, y = yloc)) +
  geom_path(color = cols.fig1[2]) +
  geom_point(aes(x=0, y=0), color = cols.fig1[6], size = 4) +
  geom_point(data = test_run %>% drop_na(s.id),
             aes(x = xloc, y = yloc), shape = "diamond", size = 2.5) +
  # geom_point(data = summ_test_run,
  #            aes(x = x, y = y), color = "#59879A") +
  labs(x = "x", 
       #title = "Example of one simulation run",
       y = "y") +
  theme_bw() -> A

test_run %>%
  ggplot(., aes(x = xloc, y = yloc)) +
  geom_path(color = "white", alpha = 0.1) +
  geom_segment(data = test_run %>% drop_na(s.id),
               aes(x = xloc, y = yloc, xend = summ_test_run$x, yend = summ_test_run$y), lty = 2, color = cols.fig1[4]) +
  geom_point(data = test_run %>% drop_na(s.id),
             aes(x = xloc, y = yloc), shape = "diamond", size = 2.5) +
  geom_point(aes(x=0, y=0), color = cols.fig1[6], size = 4) +
  geom_point(data = summ_test_run,
             aes(x = x, y = y), color = cols.fig1[4], size = 4, shape = "square") +
  labs(x = "x", 
       #title = "Average dispersal and dispersion per run",
       y = "y") +
  theme_bw() -> B

test_run %>%
  ggplot(., aes(x = xloc, y = yloc)) +
  geom_path(color = "white", alpha = 0.1) +
  geom_segment(aes(x = summ_test_run$x, xend = 0, y = summ_test_run$y, yend = 0), color = cols.fig1[1], lty = "twodash") +
  geom_segment(data = test_run %>% drop_na(s.id),
               aes(x = xloc, y = yloc, xend = 0, yend = 0), lty = 2, color = cols.fig1[6]) +
  #geom_segment(aes(x = summ_test_run$x, xend = 0, y = summ_test_run$y, yend = 0), color = "#87A986", lty = 2) +
  geom_point(data = test_run %>% drop_na(s.id),
             aes(x = xloc, y = yloc), shape = "diamond", size = 2.5) +
  geom_point(data = summ_test_run,
             aes(x = x, y = y), color = cols.fig1[4], size = 4, shape = "square") +
  geom_point(aes(x=0, y=0), color = cols.fig1[6], size = 4) +
  labs(x = "x",
       #title = "Seed dispersal distance from parent tree",
       y = "y") +
  theme_bw() -> C

# The fourth panel will show the histogram and weibull fit for the seed dispersal kernel generated from 100 simulation runs
kruns <- 100
test.df <- NULL
test.summ.df <- NULL

for(k in 1:kruns){
  a <- sim_seeds(m.prms = movrate_cp_ln, nseeds = nseeds) %>%
    mutate(run = factor(paste0("r_", k), levels = paste0("r_", 1:kruns)),
           model = "test")

  b <- summ_seeds(a) %>%
    mutate(run = factor(paste0("r_", k), levels = paste0("r_", 1:kruns)),
           model = "test")

  test.df <- rbind.data.frame(test.df, a)
  test.summ.df <- rbind.data.frame(test.summ.df, b)
}

test.df %>% drop_na(s.id) -> seed.df

weib.fit <- fitdistr(seed.df$disp, densfun = "weibull")


test.df %>%
  drop_na(s.id) %>%
  ggplot(., aes(x = disp)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = cols.fig1[7], color = cols.fig1[6]) +
  stat_function(fun = dweibull, args = list(shape = weib.fit$estimate[1], scale = weib.fit$estimate[2]),
                color = "black", alpha = 0.8, size = 1) +
  labs(x = "Distance in meters", 
       #title = "SDK from 100 runs",
       y = "Density") +
  theme_bw() -> D


plot_grid(A, B, C, D, labels = "AUTO")

# ggsave2(filename = "Ch1_movement_rates/Figures/Figure1.png")
```


**Figure1** - Simulation process overview and seed dispersal measures.  Panels A through C represent one simulation run, whereas panel D shows the results from 100 simulation runs. A) An animal starts at the origin (coordinates (0,0) represented by the teal dot) where it ingests five seeds. The animal moves in the landscape (grey trajectory path) and drops seeds (black diamonds) as it reaches their gut retention time. B) The mean seed location per run is calculated and shown in the orange square. The distance of each seed to the mean location is used to calculate seed dispersion as described in the main text. C) Average seed dispersal per run (black dashed line) is calculated as the distance from the origin (teal dot) to the mean seed location (orange square). Seed dispersal distance for each seed (teal dashed lines) are calculated as the distance of each seed from the origin. D) Seed dispersal distances for each seed in 100 simulation runs are used to generate a seed dispersal distance histogram. A Weibull distribution is fit to the data to describe the seed dispersal kernel.

# Table 1  

```{r}
ptpl %>% 
  group_by(Bird_ID, fam_g) %>% 
  summarise(movrate = round(mean(mpm),1),
            obs = n()) %>% 
  left_join(., ptpl %>% 
              group_by(fam_g) %>% 
              summarise(famrate = round(mean(mpm), 1))) %>% 
  dplyr::select(Bird_ID, obs, movrate, fam_g, famrate) -> table1

knitr::kable(table1)
# write.csv(table1, file = "Ch1_movement_rates/Figures/table1.csv")

```


# Figure 2   

```{r}
# Visualize distribution and data points

load("Ch1_movement_rates/sims_backup/movrates.RData")

cols.fig2 <- c("#23262f","#717492","#b3a82a","#c94f21","#980012","#0d907a","#b9bec3")

# Movement rates used for each scenario

# movrate_cp
# movrate_np
# movrate_pp

movratedf <- data.frame(scenario = "cp", group = NA, movrate = movrate_cp) %>% 
  bind_rows(., data.frame(scenario = rep("pp", 42), group = movrate_pp$fam_g, movrate = movrate_pp$movrate)) %>% 
  bind_rows(., data.frame(scenario = rep("np", 30), group = NA, movrate = movrate_np))

# Logfit plot

indiv_moverate %>%
  ggplot(., aes(x = movrate, y = 0.002, color = fam_g)) +
  geom_point(size = 3, alpha = 0.8) +
  # geom_point(data = fam_moverate, aes(x = movrate, y = 0.004),size = 3, alpha = 0.8, color = my.cols1[4]) +
  stat_function(fun = dlnorm, args = list(meanlog = logfit$estimate[1], sdlog = logfit$estimate[2]),
                color = "black", alpha = 0.8, size = 1) +
  scale_color_manual(values = cols.fig2) +
  labs(x = "Movement Rate (meters/minute)",
       y = "Density",
       subtitle = "Lognormal fit to individual movement rates") +
  #geom_vline(xintercept = vlines, color = my.cols1[4], size = 1, lty = 2) +
  scale_x_continuous(limits = c(0, 70)) +
  #scale_x_discrete(labels = c(0, vlines[1], 20, vlines[2], 40, vlines[3], 60)) +
  guides(color = guide_legend(title = "Social Group",
                              ncol = 2)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  NULL -> logfit_plot

# Estimate the mu's for each family group based on their movement rate.
logfit.sigma <- logfit$estimate[2]
get_mu <- function(movrate, sigma = logfit.sigma){
  mu <- log(movrate)-((sigma^2)/2)
  return(mu)
}

fam_mus <- get_mu(fam_moverate$movrate)

glines <- purrr::map(1:7, function(y)
    stat_function(fun = dlnorm, args = list(meanlog = fam_mus[y], sdlog = logfit.sigma), color = cols.fig2[y]))


fam_moverate %>%
  ggplot(., aes(x = movrate, y = -0.002, color = fam_g)) +
  geom_point(size = 3, alpha = 0.8) +
  glines +
  scale_color_manual(values = cols.fig2) +
  labs(x = "Movement Rate (meters/minute)", 
       y = "Density",
       subtitle = "Distribution for social group movement rates") +
  #geom_vline(xintercept = vlines, color = my.cols1[4], size = 1, lty = 2) +
  scale_x_continuous(limits = c(0, 70)) +
  #scale_x_discrete(labels = c(0, vlines[1], 20, vlines[2], 40, vlines[3], 60)) +
  guides(color = guide_legend(title = "Social Group",
                              ncol = 2)) +
  theme_bw() +
  theme(legend.position = c(0.8, 0.6),
        axis.title.x = element_blank()) -> social_group_curves

movratedf %>% 
  ggplot(., aes(x = movrate, y = factor(scenario, levels = c("pp", "np", "cp")), color = as.character(group))) +
  geom_jitter(size = 3, alpha = 0.8, height = 0.1) +
  scale_color_manual(values = cols.fig2) +
  scale_x_continuous(limits = c(0, 70)) +
  labs(x = "Movement Rate (meters/minute)", y = "Scenario",
       subtitle = "Sampled movement rates for each simulated scenario") +
  #scale_x_discrete(labels = c(0, vlines[1], 20, vlines[2], 40, vlines[3], 60)) +
  guides(color = guide_legend(title = "Social Group",
                              ncol = 2)) +
  theme_bw() +
  theme(legend.position = "none") +
  NULL-> movrates_used

```

```{r fig.height=7, fig.width=5}
plot_grid(logfit_plot, social_group_curves, movrates_used, nrow = 3, rel_heights = c(2,2,1), labels = "AUTO")


ggsave2(filename = "Ch1_movement_rates/Figures/Figure2.png")

```




# Figure 3 - gut retention times:  


```{r include=FALSE}
load("data/grt_data.rda") 


grt_fit <- fitdist(grt_data$grt, "gamma")
plot(grt_fit)

```

```{r}

grt_data %>% 
  ggplot() +
  geom_histogram(aes(x = grt, y = ..density..), fill = my.cols1[7], bins = 20) +
  stat_function(fun = dgamma, args = list(shape = grt_fit$estimate[1], rate = grt_fit$estimate[2])) +
  #stat_function(fun = dgamma, args = list(shape = 4, scale = 5), color = "red") + 
  geom_point(aes(x = grt, color = Bird_ID, y = 0), size = 4) +
  scale_color_manual(values = c(my.cols1[4], my.cols1[2], my.cols1[3], my.cols1[1])) +
  theme_bw() +
  labs(x = "Gut retention time in minutes", y = "Density") +
  theme(legend.position = "none")+
  NULL

# ggsave2(filename = "Ch1_movement_rates/Figures/Figure3.png")

```


 



```{r}
# Bring data --------------------------------------------
load("Ch1_movement_rates/sims_backup/datagen_cp.RData")
load("Ch1_movement_rates/sims_backup/datagen_pp.RData")
load("Ch1_movement_rates/sims_backup/datagen_np.RData")

load("Ch1_movement_rates/sims_backup/weib_cp.RData")
load("Ch1_movement_rates/sims_backup/weib_pp.RData")
load("Ch1_movement_rates/sims_backup/weib_np.RData")


```

```{r}
# Dispersion and Dispersal --------------------------------------------------------------------

cp.summ.df %>%
  dplyr::select(av.disp, dsprsn, model) %>% 
  bind_rows(., pp.summ.df %>%
              dplyr::select(av.disp, dsprsn, model)) %>%
  bind_rows(., np.summ.df %>%
              dplyr::select(av.disp, dsprsn,  model)) %>% 
  mutate(model = toupper(model),
         model = factor(model, levels = c("CP", "PP","NP"))) -> disp_df
```


# Figure 4 - average dispersal and dispersion per run  

Build a table with quantiles or summary stats for the dispersal and dispersion per run. Dispersion tells us how spread appart the seeds are from each other during a simulation. I would expect that for individuals with higher movement rates dispersion might be higher for their simulation runs too. This because a higher movement rate would extend the tail of the exponential distribution for movement distances, and thus have a larger range for movement distances, with a higher probability larger movement distances. So, during a simulation, a bird would see itself taking larger steps if they have a larger movement rate. Thus, their seeds would potentially be distributed more far apart. 


```{r}
disp_df %>% 
  group_by(model) %>% 
  summarise(av.disp = round(quantile(av.disp, c(0, 0.25, 0.5, 0.75, 0.9, 1)), digits = 1),
            dsprsn = round(quantile(dsprsn, c(0, 0.25, 0.5, 0.75, 0.9, 1)),digits = 1),
            q = c("min", 0.25, 0.5, 0.75, 0.9, "max")) %>% 
  pivot_longer(cols = c(av.disp, dsprsn), names_to = "property", values_to = "value") %>% 
  pivot_wider(., names_from = q, values_from = value) %>% 
  arrange(., property) -> qtable_models

qtable_models
```


### Idea for dispersal and dispersion 

Too many points, since we have 500k seeds, show only a percentage.


```{r fig.width=9, fig.height=3.5}

points_plot <- function(seed.data, summ.data, s.size = 50000, xylims=1250, lalpha = 0.5, scenario = NULL, twoplots = FALSE){
  
  # seed.data %>% 
  #   drop_na(s.id) %>% 
  #   mutate(dispcat = ifelse(disp <150, "non", 
  #                           ifelse(disp <500, "med", "ldd"))) %>% 
  #   #slice_head(., n = s.size) %>% 
  #   sample_n(s.size) %>% 
  #     ggplot(., aes(x = xloc, y = yloc, color = dispcat)) +
  #     geom_point(alpha = lalpha) +
  #     scale_color_manual(values = c(my.cols1[6], my.cols1[7], "black")) +
  #     geom_text(label = scenario, x = -1100, y = -1100, color = "black") +
  #     coord_equal(xlim = c(-xylims, xylims), ylim = c(-xylims, xylims)) +
  #     theme_bw() +
  #     theme(legend.position = "none",
  #           axis.title = element_blank()) +
  #      NULL -> seedlocplot
  
  seed.data %>% 
    drop_na(s.id) %>% 
    mutate(LDD = ifelse(disp <500, NA, "Over 500")) %>% 
    sample_n(s.size) %>% 
      ggplot(., aes(x = xloc, 
                    y = yloc
                    , color = LDD
                    )) +
      geom_hex()+
      scale_fill_gradient(low = "grey", high = "black") +
      #geom_point(alpha = lalpha) +
      scale_color_manual(values = c(my.cols1[6], my.cols1[7])) +
      geom_text(label = scenario, x = -1100, y = -1100, color = "black") +
      coord_equal(xlim = c(-xylims, xylims), ylim = c(-xylims, xylims)) +
      theme_bw() +
      theme(legend.position = "none",
            axis.title = element_blank()) +
       NULL -> seedlocplot
    
    if(twoplots == TRUE){
      
          summ.data %>% 
    #drop_na(s.id) %>% 
    mutate(dispcat = ifelse(av.disp <500, "non", "Over 500")) %>% 
    #slice_head(., n = s.size) %>% 
    sample_n(s.size*5) %>% 
      ggplot(., aes(x = x, y = y, color = dispcat)) +
      geom_point(alpha = lalpha) +
      labs(subtitle = scenario) +
      scale_color_manual(values = c(my.cols1[6], my.cols1[7])) +
      coord_equal(xlim = c(-xylims, xylims), ylim = c(-xylims, xylims)) +
      theme_bw() +
      theme(legend.position = "none",
            axis.title = element_blank()) +
       NULL -> summaryplot
      
      plot_grid(seedlocplot, summaryplot, ncol = 2)
    }
  
  else{seedlocplot}
}

# A <- points_plot(seed.data = cp.df, summ.data = cp.summ.df, scenario = "CP", twoplots = TRUE)
# A

A <- points_plot(seed.data = cp.df, summ.data = cp.summ.df, scenario = "CP")
B <- points_plot(seed.data = pp.df, summ.data = pp.summ.df, scenario = "PP")
C <- points_plot(seed.data = np.df, summ.data = np.summ.df, scenario = "NP") 

prow <- plot_grid(A, B, C, ncol = 3, labels = "A")


legend <- get_legend(C + scale_fill_gradient(low = "grey", high = "black",
                                             name = "Count",
                          guide = guide_colorbar(barwidth = 15, 
                                                barheight = 0.5,
                                                title.position = "left",
                                                title.vjust = 1.1,
                                                 #label.position = "left",
                                                 nbin = 100)) +
  scale_color_manual(values = c(LDD = my.cols1[6]), name = "")+
    guides(color = guide_legend(override.aes = list(fill = my.cols1[6]))) +
    theme(legend.position = "bottom"))

seedplots2d <- plot_grid(prow, legend, rel_heights = c(1,0.1), ncol = 1)
#seedplots2d


```



```{r fig.width=9, fig.height=4}

disp_df %>%
  group_by(., model) %>%
  sample_n(., 10000) %>%
  #mutate(dispcat = ifelse(disp <500, "non", "ldd")) %>%
  ggplot(., aes(y = dsprsn, x = model)) +
  geom_boxplot() +
  #geom_point(color = "grey", alpha = 0.5) +
  #scale_color_manual(values = c(my.cols1[6], my.cols1[7])) +
  labs(y = "Dispersion in meters") +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_blank()) -> p_dispersion

disp_df %>%
  group_by(., model) %>%
  sample_n(., 10000) %>%
  #mutate(dispcat = ifelse(av.disp <500, "non", "ldd")) %>%
  ggplot(., aes(y = av.disp, x = model
                #, color = dispcat
                )) +
  geom_boxplot() +
  #geom_point(color = "grey", alpha = 0.5) +
  scale_color_manual(values = c(my.cols1[6], my.cols1[7])) +
  labs(y = "Average dispersal per run in meters") +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_blank()) -> p_dispersal

disp2_plot <- plot_grid(p_dispersal, p_dispersion, ncol = 2, labels = c("B", "C"))
#disp2_plot

```

```{r fig.height=7.5, fig.width=9}
plot_grid(seedplots2d, NULL, disp2_plot, nrow = 3, rel_heights = c(1,0.2,1))

ggsave2(filename = "Ch1_movement_rates/Figures/Figure4.png")

```




# Figure 5 - All about the seed dispersal Kernels - Weibull 

Here we are using the distance of each seed

```{r}

# Weibull fit ------------------------------------------------------------

weib.boot.cp %>%
  dplyr::select(., est.shape, est.scale, boot, model) %>%
  bind_rows(., weib.boot.pp %>%
              dplyr::select(., est.shape, est.scale, boot, model)) %>%
  bind_rows(., weib.boot.np %>%
              dplyr::select(., est.shape, est.scale, boot, model)) -> joint_weib

joint_weib %>% 
  mutate(model = toupper(model),
         model = factor(model, levels = c("CP", "PP","NP"))) -> joint_weib

### Calculate the mean and variance for these weibull distributions based on their estimated parameters

meanvar.weibull <- function(shape, scale){
  
  meanweibull <- scale * gamma(1+(1/shape))
  
  varweibull <- (scale^2)*(gamma(1+(2/shape))-(gamma(1+(1/shape))^2))
  
  return(c(meanweibull, varweibull))
}


joint_weib %>% 
  mutate(meanweib = est.scale * gamma(1+(1/est.shape)),
         varweib = (est.scale^2)*(gamma(1+(2/est.shape))-(gamma(1+(1/est.shape))^2))) -> joint_weib

```



The violin plot here is made with all the data, the jitter points are a random sample of 200

```{r}
joint_weib %>%
  group_by(model) %>%
  #sample_n(., 100) %>%
  ggplot(., aes(x = model, y = est.shape)) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.01) +
  # geom_point(color = "grey", alpha = 0.5) +
  # stat_summary(fun.data=mean_sdl, mult=1,
  #              geom="pointrange", color="black") +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  geom_hline(aes(yintercept = 1), lty = "dashed") +
  labs(y = "Shape") +
  #scale_y_continuous(limits = c(0, 2)) +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL -> weib_shape

joint_weib %>%
  group_by(model) %>%
  #sample_n(., 200) %>%
  ggplot(., aes(x = model, y = est.scale)) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.01) +
  # geom_point(color = "grey", alpha = 0.5) +
  # stat_summary(fun.data=mean_sdl, mult=1,
  #              geom="pointrange", color="black") +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  labs(y = "Scale") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL-> weib_scale


joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = meanweib)) +
  geom_violin() +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  #geom_hline(aes(yintercept = 1), lty = "dashed") +
  labs(y = "Mean") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL -> weib_mean

joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = varweib)) +
  geom_violin() +
  geom_jitter(data = joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  labs(y = "Variance") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL-> weib_variance

plot_grid(weib_shape, weib_scale, weib_mean, weib_variance, ncol = 4)

#ggsave2(filename = "Ch1_movement_rates/Figures/Figure5.png")

```


```{r}
z.joint_weib <- joint_weib %>% 
  mutate(est.shape = scale(est.shape),
         est.scale = scale(est.scale),
         meanweib = scale(meanweib),
         varweib = scale(varweib))

z.joint_weib %>%
  group_by(model) %>%
  #sample_n(., 100) %>%
  ggplot(., aes(x = model, y = est.shape)) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.01) +
  # geom_point(color = "grey", alpha = 0.5) +
  # stat_summary(fun.data=mean_sdl, mult=1,
  #              geom="pointrange", color="black") +
  geom_jitter(data = z.joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  #geom_hline(aes(yintercept = 1), lty = "dashed") +
  labs(y = "Shape") +
  #scale_y_continuous(limits = c(0, 2)) +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL -> weib_shape

z.joint_weib %>%
  group_by(model) %>%
  #sample_n(., 200) %>%
  ggplot(., aes(x = model, y = est.scale)) +
  geom_violin() +
  # scale_color_manual(values = c("black", mycols)) +
  # geom_boxplot(width = 0.01) +
  # geom_point(color = "grey", alpha = 0.5) +
  # stat_summary(fun.data=mean_sdl, mult=1,
  #              geom="pointrange", color="black") +
  geom_jitter(data = z.joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  labs(y = "Scale") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL-> weib_scale


z.joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = meanweib)) +
  geom_violin() +
  geom_jitter(data = z.joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  #geom_hline(aes(yintercept = 1), lty = "dashed") +
  labs(y = "Mean") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL -> weib_mean

z.joint_weib %>%
  group_by(model) %>%
  ggplot(., aes(x = model, y = varweib)) +
  geom_violin() +
  geom_jitter(data = z.joint_weib %>% 
                group_by(model) %>% 
                sample_n(200),
              position = position_jitter(0.1)) +
  labs(y = "Variance") +
  theme_bw() +
  theme(axis.title.x = element_blank()) +
  NULL-> weib_variance

plot_grid(weib_shape, weib_scale, weib_mean, weib_variance, ncol = 4)

#ggsave2(filename = "Ch1_movement_rates/Figures/Figure5.png")

```


```{r}
z.joint_weib %>% 
  pivot_longer(., cols = c(est.shape, est.scale, meanweib, varweib)) %>% 
  ggplot(., aes(x = name, y = value, color = model)) +
  geom_boxplot() +
  theme_bw()
  
```



Kernel density estimation plots with kde1d

```{r fig.width=9, fig.height=3.5}
library(kde1d)


# Kernel density estimation:

cp.shape.kde <- kde1d(weib.boot.cp$est.shape)
pp.shape.kde <- kde1d(weib.boot.pp$est.shape)
np.shape.kde <- kde1d(weib.boot.np$est.shape)

cp.scale.kde <- kde1d(weib.boot.cp$est.scale)
pp.scale.kde <- kde1d(weib.boot.pp$est.scale)
np.scale.kde <- kde1d(weib.boot.np$est.scale)


CIs.cp.shape <- qkde1d(p=c(0.025,0.5, 0.975), cp.shape.kde)
CIs.pp.shape <- qkde1d(p=c(0.025,0.5, 0.975), pp.shape.kde)
CIs.np.shape <- qkde1d(p=c(0.025,0.5, 0.975), np.shape.kde)

CIs.cp.scale <- qkde1d(p=c(0.025,0.5, 0.975), cp.scale.kde)
CIs.pp.scale <- qkde1d(p=c(0.025,0.5, 0.975), pp.scale.kde)
CIs.np.scale <- qkde1d(p=c(0.025,0.5, 0.975), np.scale.kde)

rbind(CIs.cp.shape, CIs.pp.shape, CIs.np.shape, CIs.cp.scale, CIs.pp.scale, CIs.np.scale) %>% 
  as.data.frame() %>% 
  rename(low = V1, mean = V2, high = V3) %>%
  tibble::rownames_to_column("model") %>% 
  mutate(param = stringr::str_sub(model, start = 8),
         model =stringr::str_sub(model, start = 5, end = 6),
         model = toupper(model),
         model = factor(model, levels = c("CP", "PP", "NP"))) -> CIdata

CIdata %>% 
  filter(., param == "shape") %>% 
  ggplot(., aes(x  = model, y = mean)) +
  geom_point() +
  geom_segment(aes(y = low, yend = high, x = model, xend = model)) +
  labs(y = "Value", x = "Shape") +
  #scale_color_manual(values = my.cols1[c(1,4,6)]) +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = c(0.9, 0.2)) -> ShapeCI

CIdata %>% 
  filter(., param == "scale") %>% 
  ggplot(., aes(x  = model, y = mean)) +
  geom_point() +
  geom_segment(aes(y = low, yend = high, x = model, xend = model)) +
  labs(y = "Value", x = "Scale") +
  #scale_color_manual(values = my.cols1[c(1,4,6)]) +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = c(0.9, 0.2)) -> ScaleCI

plot_grid(ShapeCI, ScaleCI)

# The proportion of shape parameter values above the sampling distribution is 
prop.above1.10.cp.shape <- 1-pkde1d(q=1.10, cp.shape.kde)
prop.above1.10.pp.shape <- 1-pkde1d(q=1.10, pp.shape.kde)
prop.above1.10.np.shape <- 1-pkde1d(q=1.10, np.shape.kde)

```

```{r fig.width=10}
data.frame(grid_points = cp.shape.kde$grid_points, values = cp.shape.kde$values, model = "CP", param = "shape") %>% 
  bind_rows(., data.frame(grid_points = pp.shape.kde$grid_points, values = pp.shape.kde$values, model = "PP", param = "shape")) %>% 
  bind_rows(., data.frame(grid_points = np.shape.kde$grid_points, values = np.shape.kde$values, model = "NP", param = "shape")) %>% 
  bind_rows(., data.frame(grid_points = cp.scale.kde$grid_points, values = cp.scale.kde$values, model = "CP", param = "scale") %>% 
  bind_rows(., data.frame(grid_points = pp.scale.kde$grid_points, values = pp.scale.kde$values, model = "PP", param = "scale")) %>% 
  bind_rows(., data.frame(grid_points = np.scale.kde$grid_points, values = np.scale.kde$values, model = "NP", param = "scale"))) %>% 
  mutate(model = factor(model, levels = c("CP", "PP", "NP"))) -> kerneldata


kerneldata %>% 
  filter(., param == "shape") %>% 
  ggplot(., aes(x = grid_points, y = values, color = model)) +
  geom_line() +
  labs(y = "Density", x = "Shape") +
  scale_color_manual(values = my.cols1[c(1,4,6)]) +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = c(0.9, 0.2)) -> shapeplot

kerneldata %>% 
  filter(., param == "scale") %>% 
  ggplot(., aes(x = grid_points, y = values, color = model)) +
  geom_line() +
  labs(y = "Density", x = "Scale") +
  scale_color_manual(values = my.cols1[c(1,4,6)]) +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = c(0.9, 0.2)) -> scaleplot

plot_grid(shapeplot, scaleplot, ncol = 2)

# plot(cp.shape.kde$grid_points, cp.shape.kde$values, type="l", lwd=2, bty="l", col="red", ylim = c(0,4))
# lines(pp.shape.kde$grid_points, pp.shape.kde$values, col="blue")
# lines(np.shape.kde$grid_points, np.shape.kde$values, col="black")
# 
# plot(cp.scale.kde$grid_points, cp.scale.kde$values, type="l", lwd=2, bty="l", col="red", ylim = c(0,0.04))
# lines(pp.scale.kde$grid_points, pp.scale.kde$values, col="blue")
# lines(np.scale.kde$grid_points, np.scale.kde$values, col="black")


```



```{r eval=FALSE}

smean.cl.normal(weib.boot.cp$est.shape) -> cp.shape
smean.cl.normal(weib.boot.cp$est.scale) -> cp.scale

smean.cl.normal(weib.boot.pp$est.shape) -> pp.shape
smean.cl.normal(weib.boot.pp$est.scale) -> pp.scale

smean.cl.normal(weib.boot.np$est.shape) -> np.shape
smean.cl.normal(weib.boot.np$est.scale) -> np.scale


cp.df %>% 
  bind_rows(pp.df, np.df) %>% 
  drop_na(., s.id) %>% 
  group_by(model) %>% 
  sample_n(5000) %>% 
  ggplot(., aes(x = disp)) +
  geom_histogram(aes(y = ..density..), fill = "lightgray") +
  stat_function(fun = dweibull, args = list(shape = cp.shape[1], scale = cp.scale[1]), color = "blue") +
  # stat_function(fun = dweibull, args = list(shape = cp.shape[2], scale = cp.scale[2]), color = "blue", lty = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = cp.shape[3], scale = cp.scale[3]), color = "blue", lty = "dashed") +
  stat_function(fun = dweibull, args = list(shape = pp.shape[1], scale = pp.scale[1]), color = "black") +
  # stat_function(fun = dweibull, args = list(shape = pp.shape[2], scale = pp.scale[2]), color = "black", lty = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = pp.shape[3], scale = pp.scale[3]), color = "black", lty = "dashed") +
  stat_function(fun = dweibull, args = list(shape = np.shape[1], scale = np.scale[1]), color = "red") +
  # stat_function(fun = dweibull, args = list(shape = np.shape[2], scale = np.scale[2]), color = "red", lty = "dashed") +
  # stat_function(fun = dweibull, args = list(shape = np.shape[3], scale = np.scale[3]), color = "red", lty = "dashed") +
  theme_bw() +
  # geom_vline(aes(xintercept = 500)) +
  # coord_cartesian(xlim = c(500, 1700), ylim = c(0, 0.0005)) +
  NULL

```


# Table 2 - results  
Data for each seed, not per run

```{r}
# here::here()
disp_table <- read.csv("Ch1_movement_rates/Figures/table2.csv")

knitr::kable(disp_table)

```


### FIGURE 6 EVD generalized pareto results

1. Make threshold plot to figure out threshold
2. Make associated mean excess plot
3. Calculate the 95% quantile for mean excess to use as threshold
4. Make threshplot and show the threshold based on the mean excess
5. fit a gpd distribution using that threshold and report parameter values
6. Calculate conditional probabilities over certain distances

```{r results='hide'}

# subset data ---------------------------------

nsamps <- 10000
itera <- 1000


cp.df %>%
  drop_na(., s.id) %>%
  sample_n(., nsamps) -> cp.evd

pp.df %>%
  drop_na(., s.id) %>%
  sample_n(., nsamps) -> pp.evd

np.df %>%
  drop_na(., s.id) %>%
  sample_n(., nsamps) -> np.evd


cp.evd %>%
  mutate(model = toupper(model)) %>%
  bind_rows(pp.evd %>% mutate(model = toupper(model))) %>%
  bind_rows(np.evd %>% mutate(model = toupper(model))) %>%
  group_by(model) %>%
  summarise(q75 = quantile(disp, 0.75),
            q90 = quantile(disp, 0.9),
            q99 = quantile(disp, 0.99),
            max = max(disp))

# Find threshold -------------------------------------
## CP ----------------------------

r <- c(0, 600)

nint <- 100
# r <- quantile(cp.evd$disp, c(0.75, 0.99))
u.i <- matrix(seq(r[1],r[2],,nint), ncol=1)

cp.mrl <- mrlplot(cp.evd$disp)
lm.cp <- lm(cp.mrl[,2]~1)
tval.cp <- confint(lm.cp, level = 0.9)[2]

thresh.cp <- threshrange.plot(cp.evd$disp, r = r, type = "GP", nint = nint) %>%
  as.data.frame() %>%
  mutate(u.i = u.i)


## PP ----------------------------

nint <- 100
# r <- quantile(pp.evd$disp, c(0.75, 0.99))
u.i <- matrix(seq(r[1],r[2],,nint), ncol=1)

pp.mrl <- mrlplot(pp.evd$disp)
lm.pp <- lm(pp.mrl[,2]~1)
tval.pp <- confint(lm.pp, level = 0.9)[2]

thresh.pp <- threshrange.plot(pp.evd$disp, r = r, type = "GP", nint = nint) %>%
  as.data.frame() %>%
  mutate(u.i = u.i)



## NP ----------------------------

nint <- 100
# r <- quantile(pp.evd$disp, c(0.75, 0.99))
u.i <- matrix(seq(r[1],r[2],,nint), ncol=1)

np.mrl <- mrlplot(np.evd$disp)
lm.np <- lm(np.mrl[,2]~1)
tval.np <- confint(lm.np, level = 0.9)[2]

thresh.np <- threshrange.plot(np.evd$disp, r = r, type = "GP", nint = nint) %>%
  as.data.frame() %>%
  mutate(u.i = u.i)


```


```{r fig.width=12, fig.height=3}
# Threshold figures

threshplot_fx <- function(thresh_data, th, r, model){
  
  th <- round(th)

  thresh_data %>%
    ggplot(., aes(y = t.scale, x = u.i)) +
    geom_point(shape = 1, size = 2) +
    # geom_line(linetype = "dashed") +
    geom_linerange(aes(x = u.i, ymin = low.t.scale, ymax = up.t.scale)) +
    labs(title = paste(model, "threshold =", th, "m"), 
         x = "Threshold in meters", y = "Scale") +
    theme_bw() +
    geom_vline(xintercept = th, color = "red", linetype = "dashed") +
    scale_x_continuous(limits = r, n.breaks = 7 ) +
    # scale_x_continuous(name = NULL, labels = NULL, breaks = NULL) +
    # theme(axis.title.x = element_blank(),
    #       axis.ticks.x = element_blank(),
    #       axis.text.x = element_blank()) +
    # coord_cartesian(xlim = c(200, 550)) +
    NULL -> thresh_scale

  thresh_data %>%
    ggplot(., aes(y = shape, x = u.i)) +
    geom_point(shape = 1, size = 2) +
    geom_linerange(aes(x = u.i, ymin = low.shape, ymax = up.shape)) +
    labs(x = "Threshold in meters", y = "Shape") +
    theme_bw() +
    geom_vline(xintercept = th, color = "red", linetype = "dashed") +
    scale_x_continuous(limits = r, n.breaks = 7 ) +
    # coord_cartesian(xlim = c(200, 550)) +
    NULL -> thresh_shape

  plot_grid(thresh_scale, thresh_shape, nrow = 2)

}

plot.cp <- threshplot_fx(thresh_data = thresh.cp, th = tval.cp, r = r, model = "CP")
plot.pp <- threshplot_fx(thresh_data = thresh.pp, th = tval.pp, r = r, model = "PP")
plot.np <- threshplot_fx(thresh_data = thresh.np, th = tval.np, r = r, model = "NP")


plot_grid(plot.cp, plot.pp, plot.np, ncol = 3)
ggsave2(filename = "Ch1_movement_rates/Figures/Figure6.png")

```

## Fit values

```{r}

evd.fit.cp <-fevd(cp.evd$disp, threshold = tval.cp, type = "GP")
evd.fit.pp <- fevd(pp.evd$disp, threshold = tval.cp, type = "GP")
evd.fit.np <- fevd(np.evd$disp, threshold = tval.cp, type = "GP")

summary(evd.fit.cp)
summary(evd.fit.pp)
summary(evd.fit.np)

```



Find the conditional probabilities. Probability of exceeding a distance x, based on the fitted distribution

```{r}

# To find the probability of exceeding 1000, 5000, or 10,000 meters based on the fitted ged 
dist_range <- c(200, 500, 1000, 5000, 10000)

pextRemes(evd.fit.cp, dist_range, lower.tail = FALSE)
pextRemes(evd.fit.pp, dist_range, lower.tail = FALSE)
pextRemes(evd.fit.np, dist_range, lower.tail = FALSE)

# Not sure this is right though. I want the conditional probability that a dispersal distance that is already over the threshold goes beyong 1000, 5000, and 10000 meters. 


```

