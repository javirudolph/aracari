---
title: "Variation in distance between consecutive animal locations"
abstract: |
  This should be the abstract
output:
  html_document:
    df_print: paged
  word_document:
    reference_docx: docx_ref.docx
bibliography: aracari_refs.bib
csl: ecology-letters.csl
---

```{r setup, include=FALSE}
# knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE)
```

```{r}
library(tidyverse)
library(aracari)
library(stringr)
library(fitdistrplus)
library(cowplot)
library(RColorBrewer)
library(gt)

theme_set(theme_bw())
```

```{r}
aracari_df <- readRDS("aracari_df.RDS")
```

```{r eval=FALSE}
# Which individuals will we conside? Need at least a certain number of data points to fit distributions
# Don't remove any yet, just make sure you make it clear how many data points you have for each

aracari_df %>% 
  dplyr::filter(dist != 0) %>% 
  group_by(id) %>% 
  tally()

```

```{r}
# Create my focus variable and only for individuals with 30+ observations

# focus <- "dist"
# focus <- "R2n"
 focus <- "mpm"
# focus <- "m15"

if(focus == "dist"){
  df <- aracari_df %>%
  dplyr::filter(dist != 0) %>%
  group_by(id) %>%
  filter(., n() >= 30) %>%
  ungroup() %>%
  dplyr::filter(dist != 0) %>% 
    mutate(Bird_ID = paste0("B", id),
           focus = dist)
  
  dist.used <- c("lnorm", "weibull", "cauchy")
  param <- c("meanlog", "sdlog", "shape", "scale", "location", "scale")
  dist <- c("lnorm", "lnorm", "weibull", "weibull", "cauchy", "cauchy")
  kpars <- c(2, 2, 2, 2, 2, 2)
}

if(focus == "R2n"){
  df <- aracari_df %>%
  dplyr::filter(R2n != 0) %>%
  group_by(id) %>%
  filter(., n() >= 30) %>%
  ungroup() %>%
  dplyr::filter(R2n != 0) %>% 
    mutate(Bird_ID = paste0("B", id),
           focus = sqrt(R2n))
  
  dist.used <- c( "exp", "gamma", "weibull", "lnorm")
  param <- c("rate", "shape", "rate", "shape", "scale", "meanlog", "sdlog")
  dist <- c("exp", "gamma", "gamma", "weibull", "weibull", "lnorm", "lnorm")
  kpars <- c(1, 2, 2, 2, 2, 2, 2)
}

if(focus == "mpm"){
  df <- aracari_df %>% 
  dplyr::filter(dist != 0) %>% 
  group_by(id) %>%
  filter(., n() >= 30) %>%
  ungroup() %>%
  mutate(tmin = dt/60,
         mpm = dist/tmin,
         Bird_ID = paste0("B", id),
         focus = mpm) %>% 
  dplyr::filter(., mpm != 0)
  
  dist.used <- c( "exp", "gamma", "weibull", "lnorm")
  param <- c("rate", "shape", "rate", "shape", "scale", "meanlog", "sdlog")
  dist <- c("exp", "gamma", "gamma", "weibull", "weibull", "lnorm", "lnorm")
  kpars <- c(1, 2, 2, 2, 2, 2, 2)
}

if(focus == "m15"){
  df <- aracari_df %>% 
  dplyr::filter(dist != 0) %>% 
  group_by(id) %>%
  filter(., n() >= 30) %>%
  ungroup() %>%
  mutate(tmin = dt/60,
         mpm = dist/tmin,
         m15 = mpm*15,
         Bird_ID = paste0("B", id),
         focus = m15) %>% 
  dplyr::filter(., m15 != 0)
  
  dist.used <- c( "exp", "gamma", "weibull", "lnorm")
  param <- c("rate", "shape", "rate", "shape", "scale", "meanlog", "sdlog")
  dist <- c("exp", "gamma", "gamma", "weibull", "weibull", "lnorm", "lnorm")
  kpars <- c(1, 2, 2, 2, 2, 2, 2)
}


```

\newpage
# Questions  
* What is the distribution of distances between consecutive recorded locations? 
* Are there differences between individuals or can we use the same distribution to describe these distances between two locations?

The reasoning behind this, is that distances between locations can be used later on to describe variation in step length when simulating animal movement under simple models such as random walk.

### I'll go first with just the distances between locations, might switch to net displacement or net squared displacement later. 
**Visualize the variation and distribution of these distances between locations**  

```{r}
 df %>%
  ggplot(., aes((x = focus))) +
  geom_line(aes(x = focus, group = id), stat = "density", alpha = 0.4) +
  geom_line(stat = "density", color = "#1191d1", lwd = 1) +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  labs(y = "Density", x = paste(focus)) +
  theme_classic()


```

```{r}
df %>%
  ggplot(., aes(x = focus)) +
  facet_wrap(~id) +
  geom_line(stat = "density") +
  geom_vline(xintercept = 0, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  labs(y = "Density", x = paste(focus)) +
  theme_classic()
```


# Fit distribution  
Useful resource to use the package [fitdistrplus](https://cran.r-project.org/web/packages/fitdistrplus/vignettes/FAQ.html)
Also check [this](https://stackoverflow.com/questions/37152482/power-law-fitted-by-fitdistr-function-in-package-fitdistrplus). Should I do the opimization by hand?

```{r}

# Fit the four models for the population level data
  
pop <- lapply(dist.used, function(x){fitdist(df$focus, distr = x)})

# Get data for qqplot at population level
qqpop <- qqcomp(pop, plotstyle = "ggplot")$data
names(qqpop) <- c("theoretical", "fdist", "empirical")

# Save the population level parameters

build_fits_df <- function(x){

  nm <- deparse(substitute(x))

  x %>%
    map(., `[`, c("estimate", "sd", "loglik", "n")) %>%
    map(as_tibble) %>%
    bind_rows()
}

prms.df <- build_fits_df(pop) %>% 
  mutate(param = param,
         dist = dist,
         kpars = kpars,
         data = "pop")

# Repeating the process for data at the individual level
inds <- unique(as.character(df$Bird_ID))

# Fitting the four distributions for each individual and saving the parameters in a dataframe
ind.models <- NULL
for(i in 1:length(inds)){
  fit.df <- df %>% 
    dplyr::filter(., Bird_ID == inds[i])
  
  fit <- lapply(dist.used, function(x){fitdist(fit.df$focus, distr = x)})
  
  ind.models[[i]] <- fit
  
  assign(paste(inds[i]), fit)
  
  fit.prms <- build_fits_df(fit) %>% 
  mutate(param = param,
         dist = dist,
         kpars = kpars,
         data = inds[i])
  
  prms.df <- bind_rows(prms.df, fit.prms)
}


# Getting qqplot data for each individual
inds.models.data <- NULL
for(i in 1:length(inds)){
  x <- ind.models[[i]]
  
  qqdata <- qqcomp(x, plotstyle = "ggplot")$data %>% 
    mutate(data = inds[i])
  names(qqdata) <- c("theoretical", "fdist", "empirical", "individual")
  inds.models.data <- bind_rows(inds.models.data, qqdata)
}
```


```{r ind_QQplots, fig.width=12, fig.height=5}

qqpop %>% 
  mutate(individual = "POPULATION") %>% 
  ggplot(., aes(x = theoretical, y = empirical, color = fdist)) +
  facet_wrap(~individual) +
  #coord_equal() +
  geom_point(shape = 16, alpha = 0.8, size = 4) +
  geom_abline(intercept = 0, slope = 1) +
  labs(x = "Model Quantiles",
         y = "Empirical Quantiles") +
  #scale_color_viridis_d() +
  scale_color_brewer(palette = "Spectral", name = "Distribution") +
  theme(legend.position = c(0.8, 0.2)) +
  NULL -> a

inds.models.data%>% 
  ggplot(., aes(x = theoretical, y = empirical, color = fdist)) +
  #facet_grid(individual~fdist) +
  facet_wrap(~individual)+
    geom_point(shape = 16, alpha = 0.8, size = 3) +
    geom_abline(intercept = 0, slope = 1) +
    labs(x = "Model Quantiles",
         y = "Empirical Quantiles") +
  #scale_color_viridis_d() +
  scale_color_brewer(palette = "Spectral") +
  theme(legend.position = "none") +
  guides(color = guide_legend(title = "Distribution")) +
  #coord_equal() +
  NULL -> b

plot_grid(a,b, rel_widths = c(1,2), labels = "AUTO")

```

## Information criteria

```{r}

ic_calc <- function(n, kpars, loglik){
  
  BIC <- log(n)*kpars - 2*loglik
  AIC <- 2*kpars - 2*loglik
  AICc <- AIC + (2* kpars * (kpars+1)/(n-kpars-1))
}


prms.df %>% 
  mutate(BIC = log(n)*kpars - 2*loglik,
         AIC = 2*kpars - 2*loglik,
         AICc = AIC + (2* kpars * (kpars+1)/(n-kpars-1))) %>% 
  group_by(data) %>% 
  mutate(deltaBIC = signif(BIC - min(BIC), 3),
         deltaAIC = signif(AIC - min(AIC), 3),
         deltaAICc = signif(AICc - min(AICc), 3)) -> prms_ic
```

So, for each individual, which is the best fitting distribution, based on AIC or BIC? Here we are just focusing on the model fits for each individual. Best model is that with the lowest AIC or BIC, but other competitive models would be those that are within 2 units of those. 

```{r}
prms_ic %>% 
  filter(., data != "pop") %>% 
  dplyr::select(dist, data, deltaAIC,
                #deltaAICc,
                deltaBIC) %>% 
  distinct() %>% 
  pivot_longer(., cols = starts_with("delta"), names_to = "ic", values_to = "value") %>% 
  filter(value == 0) %>%  
  pivot_wider(., names_from = ic, values_from = dist) %>% 
  mutate(agree = ifelse(deltaAIC == deltaBIC, paste(deltaBIC), paste(deltaBIC, "(BIC),", deltaAIC, "(AIC)"))) %>% 
  dplyr::select(., data, agree) %>% 
  rename(Individual = data,
            `Best model` = agree)


prms_ic %>% 
  filter(., data != "pop") %>% 
  dplyr::select(dist, data, deltaAIC,
                #deltaAICc,
                deltaBIC) %>% 
  distinct() %>% 
  pivot_longer(., cols = starts_with("delta"), names_to = "ic", values_to = "value") %>% 
  filter(value > 0 & value <= 2) %>%  
  pivot_wider(., names_from = ic, values_from = dist) %>% 
  mutate(agree = ifelse(deltaAIC == deltaBIC, paste(deltaBIC), paste(deltaBIC, "(BIC),", deltaAIC, "(AIC)"))) %>% 
  dplyr::select(., data, agree) %>% 
  rename(Individual = data,
            `Best model` = agree)

```

```{r fig.width=12, fig.height=4}
# To visualize the differences in the information criteria at the individual level

prms_ic %>% 
  filter(., data != "pop") %>% 
  dplyr::select(dist, data, deltaAIC, 
                deltaAICc,
                deltaBIC) %>% 
  distinct() %>% 
  pivot_longer(., cols = starts_with("delta"), names_to = "ic", values_to = "value") %>% 
  mutate(plot_alpha = ifelse(value == "0", 1, 0.8)) %>% 
  ggplot(., aes(x = data, y = value, color = dist 
                #alpha = plot_alpha
                )) +
  facet_wrap(~ic) +
  geom_point(size = 3) +
  scale_color_brewer(palette = "Spectral") + 
  #scale_alpha_continuous(range = c(0.5, 1)) +
  labs(x = "") +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(title = "Distribution"))
  
```
Now we can compare what we call *models*, in which we compare a model that does complete pooling and considers all the data together, and the other model that considers individual variation. 
So, the complete pooling, takes all the data and fits a distribution to it. 
The individual variation models will fit a distribution to each individual. At one level we will use the same distribution for all individuals and only consider variation in parameters. At the next level, we will consider a change in parameters and distributions, where individuals can have different distributions, and this is what we call the mixed distribution model for individual variation. 

# References






